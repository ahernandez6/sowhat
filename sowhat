#!perl 

#    sowhat - SOWH test 
#        (likelihood-based test used to compare tree topologies which
#         are not specified a priori)
#
#    Copyright (C) 2013  Samuel H. Church, Joseph F. Ryan, Casey W. Dunn
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

our $VERSION = 0.16;

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use Data::Dumper;
use Cwd;
#use local lib if installing Statistics::R without sudo cpan
#use local::lib;
use Statistics::R;

our $RAX = 'raxmlHPC';
our $SEQGEN = 'seq-gen';
our $PB = 'pb -f';
our $PPRED = 'ppred';
our $PB_SAMPLING_FREQ = 5;
our $PB_SAVING_FREQ   = 1;
our $PB_BURN   = 10;
our $DEFAULT_REPS = 1000;
our $DEFAULT_RUNS = 1;
our $QUIET = 1;
our $DIR = '';
our $SCRATCH = '';
our $FREQ_BIN_NUMBER = 10;
our $TRE_PREFIX = 'RAxML_bestTree';
our $NEW_PARTITION_FILE = 'new.part.txt';
our $PART_RATE_MATRIX_PREFIX = 'RAxML_proteinGTRmodel.par';
our $NAME = '';
our $SUBZERO = 0.001;

MAIN: {
    my $rh_opts = process_options();
    
    my $ver = get_version();
    
    my (@delta_dist,@deltaprime_dist,@mean,@current_mean,
        @current_score,@pen_score,@ratio,@ratio_count,@perc_ratio,@mc_count,@pval_mc) = ();
    my $tag = 0;    
    my $alns_to_gen = 1;
    my ($restart_num,$restart_flag) = 0;
    my ($ra_params,$ra_recalc_flag,$ra_alns,$ra_rates,$ra_aln_len,$pb_id) = [ ];
    my $codon_flag = 0;

    if ($rh_opts->{'restart'}) {
        ($restart_num) = restart($rh_opts);
    }
    
    print "SOWHAT:\n";
    print "Results printed to $DIR" . "sowhat.results\n" unless($rh_opts->{'runs'} > 1);
    print "Number of runs = $rh_opts->{'runs'}. Details printed to $DIR" . "sowhat.runs.info\n" if($rh_opts->{'runs'} > 1);
    print "Results of each run printed to separate file: $DIR" . "sowhat.results.'run'\n" if($rh_opts->{'runs'} > 1);
    print "Sample: ";
    
    for (my $ts = 0; $ts < $rh_opts->{'reps'}; $ts++) {
    #LOOP: For the number of repetitions, simulate data
    #      and calculate the statistics.

        for (my $ch = 0; $ch < $rh_opts->{'runs'}; $ch++) {
        #LOOP: For the number of runs, perform each repetition of the test.
        #      This loop allows multiple runs to be performed simultaneously.

            $tag = "$ch.$ts";
            
            $restart_flag = 0;
            if (($rh_opts->{'restart'}) && ($ts <= $restart_num)) {
                $restart_flag = 1;
            }

            my ($best_ml,$best_t1,$rh_stats,$ra_diff,$fd_file) = ();

            if (($ts < 1) || ($rh_opts->{'rerun'})) {
            #For the first iteration of each run only, run the initial trees
            #and get the parameter values.

                run_initial_trees($rh_opts,$restart_flag,$tag);
                if ($rh_opts->{'usepb'}) {
                    ($pb_id)=get_params_w_pb($rh_opts,$alns_to_gen,$restart_flag,$tag);
                } else {
                    ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) = 
                    get_params($rh_opts,$tag);
                }
            }

            if ($rh_opts->{'usepb'}) {
                $ra_alns = generate_alignments_w_pb($rh_opts,$alns_to_gen,
                $restart_flag,$tag,$pb_id);
            } else {
                $ra_alns = generate_alignments($ra_aln_len,$ra_params,
                $ra_rates,$rh_opts,$alns_to_gen,$restart_flag,$tag);
            }

            for (my $i = 0; $i < @{$ra_alns}; $i++) {
            #LOOP: For the number of alignments generated under this iteration,
            #      run both raxml trees and calculate the statistic.
            #      This loop is necessary when $alns_to_gen is >1

                run_raxml_on_gen_alns($ra_alns,$rh_opts,$ra_aln_len,
                $codon_flag,$i,$restart_flag,$tag);

                ($best_ml,$best_t1,$rh_stats,$ra_diff,$fd_file) =
                evaluate_distribution($alns_to_gen,$rh_opts->{'name'},
                $rh_opts->{'rerun'},\@delta_dist,\@deltaprime_dist,\@mean,
                \@current_mean,\@current_score,\@pen_score,$i,$ts,$ch,$tag);
            }

            if ($ch == ($rh_opts->{'runs'} - 1)) {
            #After a successive iteration on all runs, 
            #evaluate statistics across runs and create a graph

                calculate_run_split(\@current_mean,\@mean,$ch,$tag);
                if ($ch) {
                    plot_runs(\@mean,$rh_opts->{'runs'},$ts);
                }
            }

            if($ts > 9) {
            #After 10 iterations on all runs,
            # begin to calculate and report the statistics.
                calc_ratio($ch,$ts,\@current_score,\@pen_score,\@ratio,\@mean);
                print_report($ch,$ts,$best_ml,$best_t1,$rh_stats,$ra_diff,
                \@delta_dist,\@ratio,$rh_opts,$fd_file,\@ratio_count,
                \@perc_ratio,\@mc_count,\@pval_mc,$ver);
            } else {
                print "-";
            }
        }
    }
}

# IN:  none
# OUT: reference to a hash of command-line options
# JOB: checks and organizes all command-line options
sub process_options {
    my $rh_opts = {};
    $rh_opts->{'reps'} = $DEFAULT_REPS;
    $rh_opts->{'runs'} = $DEFAULT_RUNS;
    $rh_opts->{'orig_options'} = [@ARGV];
    $rh_opts->{'rax'} = $RAX;
    $rh_opts->{'seqgen'} = $SEQGEN;

    my $opt_results = Getopt::Long::GetOptions(
                              "version" => \$rh_opts->{'version'},
                                "rerun" => \$rh_opts->{'rerun'},
                                 "gaps" => \$rh_opts->{'gaps'},
                                "usepb" => \$rh_opts->{'usepb'},
                                 "stop" => \$rh_opts->{'stop'},
                              "ppred=s" => \$rh_opts->{'ppred'},
                            "pb_burn=i" => \$rh_opts->{'pb_burn'},
                                 "pb=s" => \$rh_opts->{'pb'},
                         "constraint=s" => \$rh_opts->{'constraint_tree'},
                                "aln=s" => \$rh_opts->{'aln'},
                                "dir=s" => \$rh_opts->{'dir'},
                               "reps=i" => \$rh_opts->{'reps'},
                               "runs=i" => \$rh_opts->{'runs'},
                             "seqgen=s" => \$rh_opts->{'seqgen'},
                                "rax=s" => \$rh_opts->{'rax'},
                          "partition=s" => \$rh_opts->{'part'},
                                "debug" => \$rh_opts->{'debug'},
                              "restart" => \$rh_opts->{'restart'},
                              "model=s" => \$rh_opts->{'mod'},
                               "name=s" => \$rh_opts->{'name'},
                                 "help" => \$rh_opts->{'help'});

    $PPRED = $rh_opts->{'ppred'} if ($rh_opts->{'ppred'});
    $PB = $rh_opts->{'pb'} if ($rh_opts->{'pb'});
    $PB_BURN = $rh_opts->{'pb_burn'} if ($rh_opts->{'pb_burn'});
    $RAX = $rh_opts->{'rax'} if ($rh_opts->{'rax'});
    $SEQGEN = $rh_opts->{'seqgen'} if ($rh_opts->{'seqgen'});
    $QUIET = 0 if ($rh_opts->{'debug'});
    die "$VERSION\n" if ($rh_opts->{'version'});
    pod2usage({-exitval => 0, -verbose => 2}) if $rh_opts->{'help'};
    unless ($rh_opts->{'constraint_tree'} &&
            $rh_opts->{'aln'} &&
            $rh_opts->{'mod'} &&
            $rh_opts->{'name'}) {
        warn "missing --constraint\n" unless ($rh_opts->{'constraint_tree'});
        warn "missing --aln\n" unless ($rh_opts->{'aln'});
        warn "missing --name\n" unless ($rh_opts->{'name'});
        warn "missing --model\n" unless ($rh_opts->{'mod'});
        usage();
    }
    $NAME = $rh_opts->{'name'};
    set_out_dir($rh_opts->{'dir'});
    return $rh_opts;
}

# IN:  output directory specified with --dir on command-line
# OUT: none
# JOB: makes sure full path is used for output directory (required by RAX)
sub set_out_dir {
    my $opt_dir = shift;
    my $pwd = getcwd();
    if ($opt_dir) {
        $opt_dir = "$pwd/$opt_dir" if ($opt_dir !~ m/^\//);
        $opt_dir .= '/' if ($opt_dir !~ m/\/$/);
        $DIR = $opt_dir if ($opt_dir);
        $SCRATCH = "$DIR" . "scratch/";
    } else {
        warn "missing --dir\n";
        usage();
    }
    mkdir $DIR unless (-d $DIR);
    mkdir $SCRATCH unless (-d $SCRATCH);
}

# IN:  system command (e.g., ls -l)
# OUT: none
# JOB: runs a commond, prints command if in verbose mode, or if command fails
sub safe_system {
    my $cmd = shift;
    warn "\$cmd = $cmd\n" unless ($QUIET);
    my $error = system $cmd;
    warn "system call failed:\n$cmd\nerror code=$?" if ($error != 0);
}

# IN: none
# OUT: returns version of raxml
# JOB: runs raxml -v and parses the output to check version,
#      throws an error if not correct version
sub get_version {
    my $version_st = `$RAX -v`;
    my @lines= split /\n/, $version_st;
    my $version = '';
    foreach my $l (@lines) {
        next unless $l =~ m/^This is RAxML version (\d+\.\d+)/;
        $version = $1;
        last;
    }
    if ($version < 7.7) {
        warn "sowhat ERROR:\n";
        warn "You are running version $version of RAxML\n";
        die  "sowhat requires version 7.7 or higher\n";
    }
    return $version;
}

# IN: command-line options hash
# OUT: return flag for determining where to resume test
# JOB: identify the final two iterations, remove them, and signal 
#      where to resume the test
sub restart {
    my $rh_opts = shift;
    my $reps = $rh_opts->{'reps'};
    my $max = 0;
    my $num = 0;
    my $fileml = '';
    for (my $i = 0; $i < $reps; $i++) {
        $fileml = "$SCRATCH/RAxML_info.ml.0.$i.0";
        if (-e $fileml) {
            $max = $i;
        }
    }
    unlink glob "$SCRATCH/*0.$max.0*";
    $num = ($max - 1);
    unlink glob "$SCRATCH/*0.$num.0*";
    $num = ($max - 2);
    return $num;
}

# IN:  command-line options hash
#      restart flag
#      string consisting of the current rep and run
# OUT: none
# JOB: formats options and runs trees using _run_best_tree method 
#      with and without the constraint tree
sub run_initial_trees {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $mod = $rh_opts->{'mod'};
    my $tre = $rh_opts->{'constraint_tree'};

    _run_best_tree('ml',$aln,$part,$mod,$restart,$tag);
    _run_best_tree('t1',$aln,$part,$mod,$restart,$tag,$tre);
}

# IN:  title          (-n for raxml)
#      alignment file (-s for raxml)
#      partition file (-q for raxml)
#      model          (-m for raxml)
#      restart flag
#      string consisting of the current rep and run (-n for raxml)
#      treefile       (-t for raxml)
# OUT: none
# JOB: format the command line for running raxml tree
#      only includes -q partitionfile or -t treefile if they are supplied     
sub _run_best_tree {
    my $title   = shift;
    my $aln     = shift;
    my $part    = shift;
    my $mod     = shift;
    my $restart = shift;
    my $tag     = shift;
    my $tre     = shift;

    my $cmd = "$RAX -f d -p 1234 -w $SCRATCH -m $mod -s $aln -n $title.$tag";
    $cmd .= " -q $part" if ($part);
    $cmd .= " -g $tre" if ($tre);
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN:  command-line options hash
#      replicates (number of trees to generate in phylobayes)
#      restart flag
#      string consisting of the current rep and run
# OUT: the id of the phylobayes run (used later by ppred)
# JOB: format command line for phylobayes and run phylobayes
sub get_params_w_pb {
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $id = "$SCRATCH" . $rh_opts->{'name'} . ".$tag";
    my $pb_reps = $reps * $PB_SAMPLING_FREQ + $PB_BURN;
    my $pb_cmd = "$PB -d $rh_opts->{'aln'} -T $rh_opts->{'constraint_tree'} ";
    $pb_cmd .= "-x $PB_SAVING_FREQ $pb_reps $id";
    if ($QUIET) {
        $pb_cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $pb_cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($pb_cmd) unless($restart);
    return ($id);
}

# IN:  command-line options hash
#      replicates (number of trees to generate in phylobayes)
#      restart flag
#      string consisting of the current rep and run
#      id of the phylobayes run (output of get_params_w_pb method)
# OUT: array of file names of alignments
# JOB: format command-line options for ppred
#      run ppred
#      return alignment file names
sub generate_alignments_w_pb {
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $id = shift;

    my @alns = ();
    my $ppred_cmd = "$PPRED -x $PB_BURN $PB_SAMPLING_FREQ $id";

    if ($QUIET) {
        $ppred_cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $ppred_cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($ppred_cmd) unless($restart);
    for (my $i = 0; $i < $reps; $i++) {
        push @alns, "${id}_sample_${i}.ali"; 
    }
    return \@alns;
}

# IN: command-line options hash, string consistent of rep and run
# OUT: alignment length
#      flag for partitions by codon positions
#      array of parameter values
#      array of rates
# JOB: based on the model, uses one of four methods to parse params.
sub get_params {
    my $rh_opts = shift;
    my $tag = shift;
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $mod = $rh_opts->{'mod'};
    my $tre = $rh_opts->{'constraint_tree'};
    my $ra_aln_len = ();
    my $codon_flag = 0;
    my $ra_params = ();
    my $ra_rates = ();
    if ($mod =~ m/^GTRGAMMA/i) {
        ($ra_aln_len,$codon_flag,$ra_params) =
           _model_gtrgamma($aln,$part,$tre,$tag);
    } elsif ($mod =~ m/^PROT/i) {
        ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) =
           _model_prot($aln,$part,$tre,$tag);      
    } elsif ($mod =~ m/^MULTIGAMMA/i) {
        ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) =
           _model_character_data($aln,$part,$tre,$tag);
    } else {
        ($ra_aln_len,$codon_flag,$ra_params) =
           _model_non_gtr($aln,$part,$tre,$tag);        
    }
    return ($ra_aln_len,$codon_flag,$ra_params,$ra_rates);   
}

# IN: alignment file
#     partition file
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
# JOB: gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_gtrgamma {
    my $aln = shift;
    my $part = shift;
    my $tre = shift;
    my $tag = shift;
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    my ($ra_params) = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    return ($ra_aln_len,$codon_flag,$ra_params);
}

# IN: alignment file
#     partition file
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
#      array of rates
# JOB: if partitioned, makes new part file using _make_unlinked_partition_file
#      run tree using the unlinked GTR model of raxml using _run_best_tree
#      gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_prot {
    my $aln = shift;
    my $part = shift;
    my $tre = shift;
    my $tag = shift;
    my $ra_aln_len = ();
    my $codon_flag = 0;
    my $ra_params = ();
    my $ra_rates = ();
    my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
    if ($part) {
        my $ra_part_names = _make_unlinked_partition_file($part,$new_part);
        _run_best_tree('par',$aln,$new_part,'PROTGAMMAGTR_UNLINKED',$tag,$tre);
        $ra_rates = _parse_rates($tag,$ra_part_names);
        ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.par.$tag");
    } else {
        _run_best_tree('par',$aln,$part,'PROTGAMMAGTR_UNLINKED',$tag,$tre);
        $ra_rates = _parse_rates($tag);
        ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.par.$tag");
    }
    return ($ra_aln_len,$codon_flag,$ra_params,$ra_rates);      
}

# IN: alignment file
#     partition file
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
# JOB: gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_character_data {
    my $aln = shift;
    my $part = shift;
    my $tre = shift;
    my $tag = shift;
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    my ($ra_params) = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    return ($ra_aln_len,$codon_flag,$ra_params);
}

# IN: alignment file
#     partition file
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
# JOB: run tree using GTRGAMMA model
#      gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_non_gtr {
    my $aln = shift;
    my $part = shift;
    my $tre = shift;
    my $tag = shift;
    _run_best_tree('par',$aln,$part,'GTRGAMMA',$tag,$tre);
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    my $ra_params = _get_params_from_const_rax("$SCRATCH" . "RAxML_info.par.$tag");
    return ($ra_aln_len,$codon_flag,$ra_params);
}

# IN: alignment file
#     partition file
# OUT: array of lengths
#      flag for partitions by codon position
# JOB: if partitioning scheme included
#      return the length of each partition for data
#      to be simulated separately
sub _get_partition_lengths {
    my $aln = shift;
    my $part = shift;
    my $codon_flag = 0;
    my @lens = ();
    if ($part) {
        open IN, $part or _my_die("cannot open $part:$!");
        while (my $line = <IN>) {
            chomp $line;
            next if ($line =~ m/^\s*$/);
            if ($line =~ m/^[^,]+,\s*\S+\s*=\s*(\d+)-(\d+)\s*$/) {
                my $len = ($2 - $1 + 1);
                push @lens, $len;
            } elsif ($line =~ m/^[^,]+,\s*\S+\s*=\s*(\d+)-(\d+)\S(\d+)\s*$/) {
                my $len = ($2 - $1)/$3 + 1;
                push @lens, $len;
                $codon_flag = 1;
            } else {
                _my_die("unexpected line in $part");
            }
        }
    } else {
        open IN, $aln or _my_die("cannot open $aln:$!");
        my $line = <IN>;
        if ($line =~ m/^\s*\d+\s+(\d+)\s*$/) {
            @lens = $1;
        } else {
            _my_die("Alignment file should be in PHYLIP format\n");
        }
    }
    return (\@lens,$codon_flag);
}

# IN: filename
# OUT: array of parameter values
# JOB: parse the base freq., alpha value, rates, and data type
sub _get_params_from_const_rax {
    my $file = shift;
    my @data = ();
    open IN, "$file" or _my_die("cannot open $file:$!");
    my $part_num = 0;
    my @fields = ();
    my $lflag = 0;
    while (my $line = <IN>) {
        if ($line =~ m/^Partition: (\d+) with .*/) {
           $part_num = $1;
           next;
        } if ($line =~ m/^Base frequencies: (.*)/) {
            $data[$part_num]->{'freqs'}  = $1;
        } if ($line =~ m/^alpha\[/) {
            @fields = split/alpha/, $line;
            foreach my $f (@fields) {
                if ($f =~ m/^\[(\d+)\]: ([0-9.]+)( rates\[\d+\] ([^:]+): (.*))?/) {
                    $part_num = $1;
                    $data[$part_num]->{'alpha'} = $2;
                    my $rate1 = $4;
                    my $rate2 = $5;
                    next unless ($rate1);
                    my @code  = split /\s+/, $rate1 ;
                    my @rates = split /\s+/, $rate2;
                    for (my $i = 0; $i < @code; $i++) {
                        $data[$part_num]->{'rates'}->{$code[$i]} = $rates[$i];
                    }
                }
            }
        } elsif ($line =~ m/^Partition: (\d+)\s*$/) {
            $lflag = $1 + 1;
        } elsif ($lflag) {
            if ($line =~ m/^Alignment Patterns: /) {
                next;
            } elsif ($line =~ m/^Name: /) {
                next;
            } elsif ($line =~ m/DataType: (\S+)/) {
                $data[$lflag - 1]->{'type'} = $1;
                $lflag = 0;
            } else {
                _my_die("unexpected line: $line");
            }
        }
    }
    return \@data;
}    

# IN: partition file
#     new part file name
# OUT: return partition names
# JOB: print new part file with _print_unlinked_part method
sub _make_unlinked_partition_file {
    my $part = shift;
    my $new_part = shift;
    my ($ra_aa_part_ranges,$ra_part_names) = _get_aa_part_info($part);
    _print_unlinked_part($ra_aa_part_ranges,$new_part);
    return $ra_part_names;
}

# IN: partition file
# OUT: number and lengths of partitions
#      name of partitions
# JOB: get partition lengths and names for new file
sub _get_aa_part_info {
    my $part = shift;
    open IN, $part or _my_die("cannot open $part:$!");
    my @fields = ();
    my @part_info = ();
    my @names = ();
    while (my $line = <IN>) {
        chomp $line;
        next if ($line =~ m/^\s*$/);
        @fields = split/\,/, $line;
        $fields[1] or _my_die("unexpected line in part file:$line\nexpecting comma");
        push @part_info, $fields[1];
        my @name_range = split /=/, $fields[1];
        $name_range[1] or _my_die("unexpected line in part file:$line\nexpecting =");
        $name_range[0] =~ s/\s//g;
        push @names, $name_range[0];
   }
   return (\@part_info,\@names);
}

# IN: partition info
#     new part file name
# OUT: none
# JOB: print new paritition info with the GTR_UNLINKED model
#      necessary for amino acid data
sub _print_unlinked_part {
    my $part_info = shift;
    my $new_part = shift;
    open OUT, ">$new_part" or _my_die("cannot open $new_part:$!");
    for (my $i = 0; $i < @{$part_info}; $i++) {
       print OUT "GTR_UNLINKED," . "$part_info->[$i]\n";
    }
}

# IN: string consisting of rep and run
#     array of partition names
# OUT: array of rates for AA data
# JOB: Get rate matrix for AA data from raxml partition reports
sub _parse_rates {
    my $tag = shift;
    my $ra_part_names = shift;
    my @rates = ();
    if ($ra_part_names) {
        foreach my $pn (@{$ra_part_names}) {
            my @local_rates = ();
            my $matrix = "$SCRATCH" . $PART_RATE_MATRIX_PREFIX . ".$tag" . "_Partition_" . $pn;
            open IN, "$matrix" or _my_die("cannot open $matrix:$!");
            while (my $line = <IN>) {
                my @fields = split/\s/, $line;
                push @local_rates, \@fields;
            }
            push @rates, \@local_rates;
        }
    } else {
        my $matrix = "$SCRATCH" . $PART_RATE_MATRIX_PREFIX . ".$tag" . "_Partition_No Name Provided";
        open IN, "$matrix" or _my_die("cannot open $matrix:$!");
        while (my $line = <IN>) {
            my @fields = split/\s/, $line;
            push @{$rates[0]}, \@fields;
        }
    }
    return \@rates;
}

# IN: array of alignment lengths
#     array of parameter values
#     array of transtition rates
#     command line options hash
#     number of reps to be completed
#     restart flag
#     string consisting of run and rep
# OUT: none
# JOB: run seqgen
#      parse the simulated datasets
#      build the alignment files
sub generate_alignments {
    my $ra_aln_len = shift;
    my $ra_params = shift;
    my $ra_rates = shift;
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $recalc = $rh_opts->{'rerun'};
    my $gapflag = $rh_opts->{'gaps'};
    my $mod = $rh_opts->{'mod'};
    my $aln = $rh_opts->{'aln'};
    _run_seqgen($ra_aln_len,$ra_params,$ra_rates,$mod,$reps,$recalc,$restart,$tag);
    my $ra_ds = _build_datasets(scalar(@{$ra_params}),$tag);
    my $ra_alns = _make_alns($ra_ds,$gapflag,$aln,$tag);
}

# IN: array of alignment lengths
#     array of parameter values
#     array of transition rates
#     model
#     number of reps (datasets to generate)
#     recalc flag
#     restart flag
#     string consisting of rep and run
# OUT: none
# JOB: build a command for seqgen based on number of separate 
#          parameter sets (partitions)
#      use model to determine parameter type
#      if recal model, add additional count number to tag
#      run seqgen
#      if binary data, convert data type in simulated datasets
sub _run_seqgen {
    my $ra_part_lens = shift;
    my $ra_params = shift;
    my $ra_rates  = shift;
    my $model     = shift;
    my $reps      = shift;
    my $recalc    = shift;
    my $restart   = shift;
    my $tag       = shift;
    my $count     = 0;
    for (my $i = 0; $i < @{$ra_params}; $i++) {
        my $rh_part = $ra_params->[$i];
        my $cmd = "$SEQGEN -or ";
        $cmd .= "-l$ra_part_lens->[$i] ";
        $cmd .= "-a$rh_part->{'alpha'} ";
        $cmd .= "-n$reps ";
        if ($rh_part->{'type'} eq 'DNA') {
            $cmd .= "-m$model ";
            $cmd .= _get_dna_params($rh_part);
        } elsif ($rh_part->{'type'} eq 'AA') {
            $cmd .= "-mGENERAL ";
            $cmd .= _get_aa_params($rh_part,$ra_rates->[$i]);
        } elsif ($rh_part->{'type'} eq 'Multi-State') {
            $cmd .= "-mGTR ";
            $cmd .= _get_char_params($rh_part);
        } else {
            _my_die(qq~do not know how to handle type: "$rh_part->{'type'}"\n~);
        }
        if ($recalc) {
        $cmd .= " < $SCRATCH" . "$TRE_PREFIX.t1.$tag > $SCRATCH" . "seqgen.out.$tag.$count";
        } else { 
        $cmd .= " < $SCRATCH" . "$TRE_PREFIX.t1.0.0 > $SCRATCH" . "seqgen.out.$tag.$count";
        }
        $cmd .= " 2>> ${DIR}sowh_stderr_$NAME.txt" if ($QUIET);
        $count++;
        safe_system($cmd) unless($restart);
        if ($rh_part->{'type'} eq 'Multi-State') {
            my $file = "seqgen.out.$tag." . ($count - 1);
            _convert_AT_to_01("$SCRATCH" . $file, $ra_part_lens->[$i]);
        }
    }
}

# IN: parameter values
# OUT: seqgen command components
# JOB: build command based on DNA model
sub _get_dna_params {
    my $rh_part = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    _my_die("unexpected rate") unless ($rh_part->{'rates'}->{'ac'} &&
          $rh_part->{'rates'}->{'ag'} && $rh_part->{'rates'}->{'ct'} &&
          $rh_part->{'rates'}->{'cg'} && $rh_part->{'rates'}->{'at'} &&
          $rh_part->{'rates'}->{'gt'} );
    $cmd .= "-f$rh_part->{'freqs'} ";
    $cmd .= "-r$rh_part->{'rates'}->{'ac'} $rh_part->{'rates'}->{'ag'} ";
    $cmd .= "$rh_part->{'rates'}->{'at'} $rh_part->{'rates'}->{'cg'} ";
    $cmd .= "$rh_part->{'rates'}->{'ct'} $rh_part->{'rates'}->{'gt'} ";
    return $cmd;
}

# IN: parameter values
#     rate matrix for dataset
# OUT: seqgen command components
# JOB: build command based on amino acid model
sub _get_aa_params {
    my $rh_part = shift;
    my $ra_r = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    _my_die("unexpected rates") unless (scalar(@{$ra_r}) == 21);
    $cmd .= "-f$rh_part->{'freqs'} ";
    my $j = 0;
    $cmd .= "-r";
    for (my $i = 0; $i < 20; $i++) {
        $j++;
        for (my $k = $j; $k < 20; $k++) {
            $cmd .= "$ra_r->[$i]->[$k], ";
        }
    }
    return $cmd;
}

# IN: parameter values
# OUT: seqgen command components
# JOB: build command based on binary character model
sub _get_char_params {
    my $rh_part = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    $rh_part->{'freqs'} =~ s/^\s*//;
    $rh_part->{'freqs'} =~ s/\s*$//;
    my @freqs = split /\s+/, $rh_part->{'freqs'};
    unless (scalar(@freqs) == 2) {
        _my_die("expecting 2 frequencies. Multi-State only works w/binary matrix\n");
    }
    $cmd .= "-f$freqs[0],0.0,0.0,$freqs[1] ";
    return $cmd;
}

# IN: filename of simulated dataset
#     partition lengths
# OUT: none
# JOB: change simulated data from AT to 01 (nucleotide to binary)
sub _convert_AT_to_01 {
    my $file  = shift;
    my $num_cols = shift;
    my $updated = '';
    open IN, $file or _my_die("cannot open $file:$!");
    while (my $line = <IN>) {
        chomp $line;
        if ($line =~ m/^(\S+\s+)(\S+)$/) {
            my $id = $1;
            my $seq = $2;
            if (length($seq) == $num_cols) {
                $seq =~ tr/AT/01/;
                $updated .= "$id$seq\n";
            } else {
                $updated .= "$line\n";
            }
        } else {
            $updated .= "$line\n";
        }
    }
    close IN;
    open OUT, ">$file" or _my_die("cannot open >$file:$!");
    print OUT $updated;
    close OUT;
}

# IN: number of separater parameter sets (partitions)
#     string consisting of rep and run
# OUT: array of simulated data
# JOB: parse titles and data
#      build alignment files
sub _build_datasets {
    my $num = shift;
    my $tag = shift;
    my @allseqs = ();
    my $ra_ids = _get_ids_from_seqgen_out("$SCRATCH" . "seqgen.out.$tag.0");
    for (my $i = 0; $i < $num; $i++) {
        my $ra_seqs = _get_seqs_from_seqgen_out("$SCRATCH" . "seqgen.out.$tag.$i");
        push @allseqs, $ra_seqs;
    }
    my $ra_ds = _make_datasets_from_allseqs($ra_ids,\@allseqs);
    return $ra_ds;
}

# IN: filename of first simulated dataset
# OUT: array of taxa titles
# JOB: parse taxa titles
sub _get_ids_from_seqgen_out {
    my $file = shift;
    my @ids = ();
    open IN, $file or _my_die("cannot open $file:$!");
    my $topline = <IN>;
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*$/);
        last if ($line eq $topline);
        my @fields = split /\s+/, $line;
        push @ids, $fields[0];
    }
    return \@ids;
}

# IN: filename of each simulated dataset
# OUT: array of simulated data
# JOB: parse simulated data
sub _get_seqs_from_seqgen_out {
    my $file = shift;
    my @seqs = ();
    open IN, $file or _my_die("cannot open $file:$!");
    my $topline = <IN>;
    my $count = 0;
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*$/);
        if ($line eq $topline) {
            $count++;
            next;
        }
        chomp $line;
        my @fields = split /\s+/, $line;
        push @{$seqs[$count]}, $fields[1];
    }
    return \@seqs;
}

# IN: array of taxa titles
#     array of simulated data
# OUT: array of formatted alignment file content
# JOB: concatenate data, format for alignment files
sub _make_datasets_from_allseqs {
    my $ra_ids = shift;
    my $ra_all = shift;
    my @ds = ();
    foreach my $ra_seqs (@{$ra_all}) {
        for (my $i = 0; $i < @{$ra_seqs}; $i++) {
            for (my $j = 0; $j < @{$ra_ids}; $j++) {
                 $ds[$i]->[$j] .= "$ra_seqs->[$i]->[$j]";
            }
        }
    }
    my $len = _get_len_from_id_lens($ra_ids);
    my @formatted = ();
    my $seqlen = length($ds[0]->[0]);
    my $numseq = scalar(@{$ds[0]});
    my $header = " $numseq $seqlen\n";
    foreach my $ra_d (@ds) {
        my $aln = $header;
        for (my $i = 0; $i < @{$ra_ids}; $i++) {
            $aln .= sprintf("%${len}s", $ra_ids->[$i]);
            $aln .= "$ra_d->[$i]\n";
        }
        push @formatted, $aln;
    }
    return \@formatted;
}

# IN: array of taxa titles
# OUT: length of titles
# JOB: return lenght of titles for alignment files
sub _get_len_from_id_lens {
    my $ra_ids = shift;
    my $longest = 0;
    foreach my $id (@{$ra_ids}) {
        $longest = length($id) if (length($id) > $longest);
    }
    my $sprintf_val = (($longest + 1) * -1);
    return $sprintf_val;
}

# IN: array of formatted datasets
#     flag for gap replacement
#     actual alignment file
#     string consisting of rep and run
# OUT: simulated alignment files
# JOB: print array of formatted datasets into alignment files
#      if gap flag, superimpose gaps from real data to 
#          simulated files (run gapstencil.py)
sub _make_alns {
    my $ra_ds = shift;
    my $gapflag = shift;
    my $aln = shift;
    my $tag = shift;
    my @files = ();
    for (my $i = 0; $i < @{$ra_ds}; $i++) {
        my $file = "$SCRATCH" . "aln.phy.$tag.$i";
        open OUT, ">$file" or _my_die("cannot open >$file:$!");
        print OUT $ra_ds->[$i];
        if($gapflag) {
            my $cmd = "python dependencies/gapstencil ";
            $cmd .= "-i " . "$aln ";
            $cmd .= "-o " . "$SCRATCH" . "aln.phy.$tag.$i";
            safe_system($cmd);
        }
        push @files, $file;
    }
    return \@files;
}

# IN: array of simulated alignments
#     command-line hash of options
#     length of alignments
#     flag for partitioning by codon position
#     iteration
#     restart flag
#     string containing rep and run
# OUT: none
# JOB: if partitioned by codon position, create new partitioning scheme
#      run RAxML on simulated alignments
sub run_raxml_on_gen_alns {
    my $ra_alns = shift;
    my $rh_opts = shift;
    my $ra_aln_len = shift;
    my $codon_flag = shift;
    my $i = shift;
    my $restart = shift;
    my $tag = shift;
    my $part = $rh_opts->{'part'};
    my $mod = $rh_opts->{'mod'};
    my $tre = $rh_opts->{'constraint_tree'};
    if ($codon_flag) {
        my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
        my $ra_part_titles = _get_part_titles($part);
        my $ra_ranges = _print_ranges($ra_aln_len);
        _print_new_part_file($ra_part_titles,$ra_ranges,$new_part);
        _run_rax_on_genset($ra_alns,$mod,$new_part,$tre,$i,$restart,$tag);
    } else {
        _run_rax_on_genset($ra_alns,$mod,$part,$tre,$i,$restart,$tag);
    }
}

# IN: parition file
# OUT: array of partition titles
# JOB: parse partition titles
sub _get_part_titles {
    my $part = shift;
    my @titles = ();
    open IN, $part or _my_die("cannot open $part:$!");
    while (my $line = <IN>) {
        chomp $line;
        next if ($line =~ m/^\s*$/);
        if ($line =~ m/^(\s*\S+,\s*\S+\s*=\s*)\d+-\d+\S*\s*$/) {
            my $title = $1;
            push @titles, $title;
        } else {
            _my_die("unexpected line in $part");
        }
    }
    return \@titles;
}

# IN: alignment length
# OUT: array of partition lengths
# JOB: parse partition lengths
sub _print_ranges {
    my $ra_lens = shift;
    my $i = 0;
    my $last = 0;
    my @ranges = ();
    foreach my $d (@{$ra_lens}) {
        my $lt = ($last + 1);
        my $rt = ($last + $d);
        push @ranges, "$lt-$rt";
        $last += $d;
    }
   return \@ranges;
}

# IN: array of partition titles
#     array of partition lengths
# OUT: none
# JOB: print new partition files for codon positions
sub _print_new_part_file {
    my $ra_part_titles = shift;
    my $ra_ranges = shift;
    my $file = shift;
    open OUT, ">$file" or _my_die("cannot open $file:$!");
    for (my $i = 0; $i < @{$ra_ranges}; $i++) {
        print OUT "$ra_part_titles->[$i]";
        print OUT "$ra_ranges->[$i]\n";
    }
}

# IN: array of simulated alignments
#     model
#     partition file
#     tree file
#     iteration
#     restart flag
#     string consisting of rep and run
# OUT: none
# JOB: create command for RAxML
#      run command
#      create command constrained by tree
#      run command
sub _run_rax_on_genset {
    my $ra_alns = shift;
    my $mod     = shift;
    my $part    = shift;
    my $cmd     = '';
    my $tre     = shift;
    my $i       = shift;
    my $restart = shift;
    my $tag     = shift;
    $cmd  = "$RAX -p 1234 -w $SCRATCH -m $mod -s $ra_alns->[$i] ";
    $cmd .= "-n ml.$tag.$i";
    if ($part) {
        $cmd .= " -q $part ";
    }
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
    $cmd  = "$RAX -p 1234 -w $SCRATCH -m $mod -s $ra_alns->[$i] ";
    $cmd .= "-n t1.$tag.$i -g $tre";
    if ($part) {
        $cmd .= " -q $part ";
    }
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN: number of reps
#     filename
#     recalculation flag
#     array of likelihood differences in real data
#     array of likelihood differences in sim data
#     array of mean differences
#     mean difference at last iteration
#     current stopping score
#     last stopping score
#     iteration
#     rep
#     run
# OUT: max likelihood score of new iteration
#      constrained likelihood of new iteration
#      hash of statistical measures
#      array of likelihood differences for this run
#      distribution file
# JOB: set stopping score to last stopping score
#      parse most recent values for null distribution 
#      if recalculate, create distribution of test stats
#      calculate liklihood differences  
#      parse additional statitistics
#      print distribution of differences
sub evaluate_distribution {
    my $reps = shift;
    my $name = shift;
    my $recalc = shift;
    my $ra_delta_dist = shift;
    my $ra_deltaprime_dist = shift;
    my $ra_mean = shift;
    my $ra_current_mean = shift;
    my $ra_current_score = shift;
    my $ra_pen_score = shift;
    my $i = shift;
    my $ts = shift;
    my $ch = shift;
    my $tag = shift;
    my $best_ml_score = 0;
    my $best_t1_score = 0;

    $ra_pen_score->[$ch] = $ra_current_score->[$ch];

    my $ra_dist = _get_distribution($reps,0,$i,$tag);
    my $ra_const_dist = _get_distribution($reps,1,$i,$tag);
    if ($recalc) {
        $best_ml_score = _get_best_score("$SCRATCH" . "RAxML_info.ml.$tag");
        $best_t1_score = _get_best_score("$SCRATCH" . "RAxML_info.t1.$tag");
        $ra_delta_dist->[$ch][$ts] = $best_ml_score - $best_t1_score;
    } else {
        $best_ml_score = _get_best_score("$SCRATCH" . "RAxML_info.ml.0.0");
        $best_t1_score = _get_best_score("$SCRATCH" . "RAxML_info.t1.0.0");
        $ra_delta_dist->[$ch][0] = $best_ml_score - $best_t1_score;
    }

    # next 2 lines avoid uninitialized errors
    $ra_dist->[$i] = $ra_dist->[$i] || 0;
    $ra_const_dist->[$i] = $ra_const_dist->[$i] || 0;

    $ra_deltaprime_dist->[$ch][$ts] = $ra_dist->[$i] - $ra_const_dist->[$i];

    my $rh_stats = _get_stats($ra_delta_dist->[$ch],$ra_deltaprime_dist->[$ch]);
    $ra_mean->[$ch][$ts] = $rh_stats->{'mean'};
    $ra_current_mean->[$ch] = $rh_stats->{'mean'};
    $ra_current_score->[$ch] = $rh_stats->{'z'};

    my $fd_file = _print_freq_dist($ra_deltaprime_dist->[$ch],$name,$reps);
    return ($best_ml_score,$best_t1_score,$rh_stats,$ra_deltaprime_dist->[$ch],$fd_file);
}

# IN: number of repetitions
#     flag for constrained ml score
#     iteration
#     string consisting of rep and run
# OUT: array of likelihood scores
# JOB: parse likelihood scores from RAxML output
sub _get_distribution {
    my $reps = shift;
    my $w_const = shift;
    my $j = shift;
    my $tag = shift;
    my @dist = ();
    for (my $i = 0; $i <= $j; $i++) {
        my $file = '';
        if ($w_const) {
            $file = "$SCRATCH" . "RAxML_info.t1.$tag.$i";
        } else {
            $file = "$SCRATCH" . "RAxML_info.ml.$tag.$i";
        }
        open IN, $file or _my_die("cannot open $file:$!");
        while (my $line = <IN>) {
            if ($line =~ m/^Inference\[0\] final[^:]+: ([-0-9.]+)/) {
                my $likelihood = $1;
                _my_die("unexpected multiple matches in $file") if ($dist[$i]);
                $dist[$i] = $likelihood;
            }
            chomp $line;
        }
    }
    return \@dist;
}


# IN: filename
# OUT: likelihood score
# JOB: parse likelihood score of real data
sub _get_best_score {
    my $file = shift;
    my $ml_score = '';
    open IN, $file or _my_die("cannot open $file:$!");
    while (my $line = <IN>) {
        chomp $line;
        if ($line =~ m/^Final GAMMA-based Score of best tree (\S+)/) {
            $ml_score = $1;
        }
        if ($line =~ m/^Final ML Optimization Likelihood: (\S+)/) {
            $ml_score = $1;
        }
    }
    return $ml_score;
}

# IN: array of test statistics
#     array of null distribution
# OUT: hash of statistics
# JOB: run R for statistical test
sub _get_stats {
    my $ra_delta_dist = shift;
    my $ra_deltaprime_dist = shift;
    my $ts = scalar(@{$ra_deltaprime_dist});
    my $delta_string = @{$ra_delta_dist};
    my $deltaprime_string = @{$ra_deltaprime_dist};
    my $R = Statistics::R->new();
    if($ts > 1) {
        $delta_string = join ', ', @{$ra_delta_dist};
        $deltaprime_string = join ', ', @{$ra_deltaprime_dist};
    }
    $R->startR();

my $cmds = <<EOF;
a <- mean(c($deltaprime_string))
s <- sd(c($deltaprime_string))
n <- $ts
xbar <- mean(c($delta_string))
z <- (xbar-a)/(s/sqrt(n))
p <-  pnorm(z, lower.tail = FALSE)
v <- var(c($deltaprime_string))
se <- (s/sqrt(n))
rse <- abs((se/a) * 100)
a
s
n
xbar
z
p
v
se
rse
EOF
    my $r_out = $R->run($cmds);
    $R->stopR();
    my $rh_stats = _parse_stats($r_out);
    return $rh_stats;
}

# IN: output of R
# OUT: hash of statistics
# JOB: parse R output
sub _parse_stats {
    my $str = shift;
    my %stats = ();
    $str =~ s/^\[\d+\] // or warn "unexpected output from R";
    my @data = split /\n\[\d+\] /, $str;
    $stats{'mean'} = $data[0];
    $stats{'stdev'} = $data[1];
    $stats{'sample_size'} = $data[2];
    $stats{'diff'} = $data[3];
    $stats{'z'} = $data[4];
    $stats{'p'} = $data[5];
    $stats{'var'} = $data[6];
    $stats{'se'} = $data[7];
    $stats{'rse'} = $data[8];
    return \%stats;
}

# IN: array of null distribution
#     filename
#     string consisting of rep and run
# OUT: distribution filename
# JOB: print null distribution
sub _print_freq_dist {
    my $ra_d = shift;
    my $name = shift;
    my $tag = shift;
    my %bins = ();
    my @sorted = sort {$a <=> $b} @{$ra_d};
    my $low  = $sorted[0];
    my $high = $sorted[-1];
    my $div = ($high - $low) / $FREQ_BIN_NUMBER;
    my $current_bin = $low;
    my $i = 0;
    while ($i < @sorted) {
        if ($sorted[$i] > ($current_bin + $div)) {
           $current_bin += $div
        } else {
            $bins{$current_bin}++;
        }
        $i++;
    }
    my $d_file = "$DIR" . "sowhat.distribution";
    open OUT, ">$d_file" or _my_die("cannot open >$d_file:$!");
    print OUT "Null Distribution Frequencies:\n";
    foreach my $bin (sort {$a <=> $b} keys %bins) {
        print OUT "$bin\t$bins{$bin}\n";
    }
    print OUT "\nNull Distribution\n";
    foreach my $dist_val (@sorted) {
        print OUT "$dist_val\n";
    }
    close OUT;
    return $d_file;
}

# IN: array of cumulative mean of null dist
#     runs
#     reps
# OUT: none
# JOB: plot cumulative mean of all runs
sub plot_runs {
    my $ra_mean = shift;
    my $runs = shift;
    my $ts = shift;
    my $R = Statistics::R->new();
    my $ra_mean_str = ();
    my $i = 0;
    if(scalar($ts > 0)) {
        foreach(@{$ra_mean}) {
            $ra_mean_str->[$i] = "m[,($i + 1)] <- c(" . join ( ', ', @{$ra_mean->[$i]}) . ');';
            $i++;
        }
        my $ra_str = join ( "\n", @{$ra_mean_str});
        $R->startR();
  
        my $cmds = <<EOF;
m <- data.frame(row.names=1:($ts + 1))
$ra_str
postscript("$DIR/allmeans.$runs.eps",horizontal = FALSE, onefile = FALSE, paper = "special",width=6.0,height=6.0)
par(mar=c(5, 4, 4, 2) + 0.1)
plot(m[,1],ylim=c(min(m),max(m)),type="l",ylab="Cumulative Mean of Null Distribution", xlab="Sample Size") 
for (i in 2:$runs){
lines(m[,i],type="l",col=i)
}
dev.off()
EOF
        my $r_out = $R->run($cmds);
        $R->stopR();
    }
}

# IN: array of current mean of null
#     array of all means of null
#     run
#     rep
# OUT: none
# JOB: calculate difference between runs
sub calculate_run_split {
    my $ra_current_mean = shift;
    my $ra_mean = shift;
    my $ch = shift;
    my $tag = shift;
    my $file = $DIR . "sowhat.runs.info";
    open OUT, ">$file" or _my_die("cannot open >$file:$!");
    foreach my $ra_m (@{$ra_mean}) {
        print OUT "\nMean of null distribution of run as sample increases: \n";
        foreach my $val (@{$ra_m}) {
            print OUT "$val\n";
        }
    }
    foreach my $val (@{$ra_current_mean}) { 
        print OUT "\nFinal Mean of Run = $val";
    }
    for (my $i = 1; $i <= $ch; $i++) {
        my $diff = $ra_current_mean->[$i] - $ra_current_mean ->[($i - 1)];
        print OUT "\nDifference between runs " . ($i - 1) .  " and $i: $diff\n";
    }
    close OUT;
}

# IN: run
#     rep
#     current stopping score
#     last stopping score
#     ratio of current score to last
#     array of mean values
# OUT: none
# JOB: calculate stopping ratio
#      plot stopping ratio of each run
#      plot cumulative mean of each run 
sub calc_ratio {
    my $ch = shift;
    my $ts = shift;
    my $ra_current_score = shift;
    my $ra_pen_score = shift;
    my $ra_ratio = shift;
    my $ra_mean = shift;
    my $calc_ratio = 0;
    $ra_current_score = $ra_current_score->[$ch];
    $ra_pen_score = $ra_pen_score->[$ch];
    $calc_ratio = $ra_current_score / $ra_pen_score;
    $ra_ratio->[$ch][$ts] = abs(1-$calc_ratio);

    my $R = Statistics::R->new();
    for(my $j=0; $j < 10; $j++) {
        $ra_ratio->[$ch][$j] = 0;
    }

    $ra_ratio = $ra_ratio->[$ch]; 
    $ra_mean = $ra_mean->[$ch]; 

    if(scalar(@{$ra_ratio}) > 1) {
        my $ratio_str = join ', ', @{$ra_ratio};
        my $mean_str = join ', ', @{$ra_mean};

        $R->startR();
        my $cmds = <<EOF;
rationull <- c($ratio_str)
postscript("$DIR/ratio.$ch.eps",horizontal = FALSE, onefile = FALSE, paper = "special",width=4.0,height=4.0)
par(mar=c(5, 4, 4, 2) + 0.1)
plot(rationull,ylim=c(min(rationull),max(rationull)),ylab="1 - Ratio", xlab="Sample Size",pch=20) 
dev.off()
meannull <- c($mean_str)
postscript("$DIR/mean.$ch.eps",horizontal = FALSE, onefile = FALSE, paper = "special",width=4.0,height=4.0)
par(mar=c(5, 4, 4, 2) + 0.1)
plot(meannull,type="l",ylim=c(min(meannull),max(meannull)),ylab="Cumulative Mean of Null Distribution", xlab="Sample Size") 
dev.off()
EOF
        my $r_out = $R->run($cmds);
        $R->stopR();
    }
}

# IN: run
#    rep
#    real max likelihood score
#    real constrained score
#    hash of statistics
#    array of test statistics
#    array of null distribution
#    array of stopping ratios
#    hash of command-line options
#    frequency filename
#    stopping ratio count
#    stopping ration percent
#    mc count
#    mc p-value
#    version
# OUT: none
# JOB: calculate percent of stopping score to sample
#      print report
sub print_report {
    my $ch = shift;
    my $ts = shift;
    my $best_ml = shift;
    my $const_ml = shift;
    my $rh_s = shift;
    my $ra_d = shift;
    my $current_d = $ra_d->[$ts];
    my $ra_delta_dist = shift;
    $ra_delta_dist = $ra_delta_dist->[$ch];
    my $ra_ratio = shift;
    my $rh_opts = shift;
    my $fd_file = shift;
    my $ra_ratio_count = shift;
    my $ra_perc_ratio = shift;
    my $ra_mc_count = shift;
    my $ra_pval_mc = shift;
    my $version = shift;
    my $ratio = $ra_ratio->[$ch][$ts];
    my $file = '';

    if ($rh_opts->{'runs'} > 1) {
        $file = $DIR . "sowhat.results.$ch";  
    } else {
        $file = $DIR . "sowhat.results";
    }

    if($ratio <= 0.01) {
        print "o";
        $ra_ratio_count->[$ch]++;
    } else {
        print ".";
    }

    if($current_d >= $rh_s->{'diff'}) {
        $ra_mc_count->[$ch]++;
    }

    no warnings 'uninitialized';
    $ra_perc_ratio->[$ch] = ($ra_ratio_count->[$ch] / $rh_s->{'sample_size'}) * 100;
    $ra_pval_mc->[$ch]    = ($ra_mc_count->[$ch] / $rh_s->{'sample_size'});
    use warnings 'uninitialized';
    if($ra_perc_ratio->[$ch] > 50 && $rh_s->{'sample_size'} > 100) {
        exit if($rh_opts->{'stop'});
    }
    open OUT, ">$file" or _my_die("cannot open >$file:$!");
    print OUT "\n\n";
    print OUT "=============================================================\n";
    print OUT "                   sowhat OUTPUT\n";
    print OUT "=============================================================\n\n";
    print OUT "\n\nProgram was called as follows:\n$0 \\\n";
    foreach my $arg (@{$rh_opts->{'orig_options'}}) {
        print OUT "  $arg \\\n";
    }
    print OUT "\n  \$SEQGEN variable set to $SEQGEN\n";
    print OUT "  \$RAX variable set to $RAX\n";
    print OUT "  RAxML was version $version\n";
    print OUT "\nDistributions and frequencies printed to:\n $fd_file\n";
    print OUT "\nTest Statistic:\n";
    print OUT "    ML value of best tree: $best_ml\n";
    print OUT "    ML value of best tree w/constraint: $const_ml\n";
    print OUT "    Difference between $best_ml and $const_ml: $rh_s->{'diff'}\n";
    print OUT "\nStatistics of the null distribution:\n";
    print OUT "    Size of null distribution: $rh_s->{'sample_size'}\n";
    print OUT "    Mean of null distribution: $rh_s->{'mean'}\n";
    print OUT "    Standard deviation of null distribution: $rh_s->{'stdev'}\n";
    print OUT "    Standard error of null distribution: $rh_s->{'se'}\n";
    print OUT "    Relative standard error: $rh_s->{'rse'}" . "%\n";
    print OUT "    Variance of null distribution: $rh_s->{'var'}\n";
    print OUT "\nStopping Criteria:\n";
    print OUT "    The value of 1 - ratio of z-scores as the sample size increases\n";
    print OUT "    will approach 0. The percent of iterations which return values\n";
    print OUT "    of 1-ratio < 0.01 is shown. Sufficient sampling is >50%\n";
    print OUT "\n    Current z-score: $rh_s->{'z'}\n";
    print OUT "    Percent Ratio: $ra_perc_ratio->[$ch]" . "%\n";
    print OUT "\nSOWH test results:\n";
    print OUT "    The p-value represents the probability that the test statistic\n";
    print OUT "    would be observed under the null hypothesis.\n";
    print OUT "\n    Monte Carlo count $ra_mc_count->[$ch]\n";
    print OUT "    Monte Carlo p-value: $ra_pval_mc->[$ch]\n";
    print OUT "\n    Parametric test p-value: $rh_s->{'p'}\n";
    close OUT;
    open OUT, ">>$fd_file" or _my_die("cannot open >$fd_file:$!");
    print OUT "\nNull Distribution:\n";
    foreach my $val (@{$ra_d}) {
       print OUT "$val\n";
    }
    print OUT "\nDistribution of Test Statistics:\n" if($ra_delta_dist);
    foreach my $val (@{$ra_delta_dist}) {
       print OUT "$val\n";
    }
    close OUT;
}

# IN: message
# OUT: none
# JOB: warn when file cannot be opened
sub _my_die {
    my $msg  = shift;
    my $file = "${DIR}sowh_stderr_$NAME.txt";
    open IN, $file or warn "cannot open $file:$!";
    while (my $line = <IN>) {
        warn $line;
    }
    warn "sowhat died unexpectedly\n";
    die $msg;
}

sub usage {
    die "usage: $0
    --constraint=NEWICK_CONSTRAINT_TREE
    --aln=PHYLIP_ALIGNMENT
    --name=NAME_FOR_REPORT
    --model=MODEL
    --dir=DIR
    [--rax=RAXML_BINARY_OR_PATH_PLUS_OPTIONS]
    [--seqgen=SEQGEN_BINARY_OR_PATH_PLUS_OPTIONS]
    [--usepb]
    [--stop]
    [--pb=PB_BINARY_OR_PATH_PLUS_OPTIONS]
    [--pb_burn=BURNIN_TO_USE_FOR_PB_TREE_SIMULATIONS]
    [--reps=NUMBER_OF_REPLICATES]
    [--runs=NUMBER_OF_RUNS]
    [--partition=PARTITION_FILE]
    [--rerun]
    [--restart]
    [--gaps]
    [--debug]
    [--help]
    [--version]\n";
}

__END__

=head1 NAME

B<sowhat> - The SOWH-Test: A Paramentric Test of Topologies

=head1 AUTHOR

Samuel H. Church <samuel_church@brown.edu>, Joseph F. Ryan <joseph.ryan@whitney.ufl.edu>, Casey W. Dunn <casey_dunn@brown.edu>

=head1 SYNOPSIS 

sowhat --constraint=NEWICK_CONSTRAINT_TREE --aln=PHYLIP_ALIGNMENT --name=NAME_FOR_REPORT --model=MODEL --dir=DIR [--rax=RAXML_BINARY_OR_PATH_PLUS_OPTIONS] [--seqgen=SEQGEN_BINARY_OR_PATH_PLUS_OPTIONS] [--usepb] [--pb=PB_BINARY_OR_PATH_PLUS_OPTIONS] [--pb_burn=BURNIN_TO_USE_FOR_PB_TREE_SIMULATIONS] [--reps=NUMBER_OF_REPLICATES] [--runs=NUMBER_OF_RUNS] [--partition=PARTITION_FILE] [--rerun] [--debug] [--help] [--version]\n";

=head1 constraint

=over 2

This programs is designed to test a hypothesized topology, here provided as a constraint tree, against the best topology obtained in a maximum likelihood analysis of the data.

=back

=head1 aln

=over 2

This file is the alignment file which will be used to estimate likelihood scores and free parameters. This alignment file must be in phylip format.

=back

=head1 name

=over 2

This is the name of the output files.

=back

=head1 model

=over 2

This is the model which will be used to estimate the likelihood scores of the original dataset the scores of each of the generated datasets with and without the topology constrained according to the hypothesis. GammaGTR is used to generate parameters for null dataset regardless of the model specified (unless --usepb is specified, in which case phylobayes is used to generate parameters).

=back

=head1 dir

=over 2

This is the directory where ouput files will be sent.

=back

=head1 OPTIONS

=over 2

=item B<--rax>

<default: raxmlHPC>
This allows the user to specify the RAxML binary to be used in the analysis. It is useful if a user would like to specify the full path to a RAxML binary, but its purpose is mostly to allow users to run a multi-threaded or MPI version of the program, and or pass additional parameters to RAxML. Some examples would be:

    --rax='raxmlHPC-PTHREADS-SSE3 -T 8'

    --rax='mpirun -n 8 raxmlHPC-MPI'

=item B<--seqgen>

<default: seq-gen>
This allows the user to specify the SeqGen binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to seq-gen

=item B<--usepb>

Use PhyloBayes (pb and ppred programs) to calculate null distribution parameters and generate data sets instead of using RAxML and Seq-Gen. Only works for amino acid and nucleotide datasets (not character data)

=item B<--stop>

This option allows the program to stop when sufficient sample size is reached, under a given stopping criterion. The value of reps is the maximum number of simulations the program will calculate. This is measured by comparing the frequency of iterations of simulation which return non-extreme values, as measured by calculating 1 - the ratio of z-scores after each new simulation is added. The plot of this ratio is included as ratio.eps

=item B<--pb>

<default: pb>
This allows the user to specify the pb binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to pb (only useful with --usepb)

=item B<--ppred>

<default: ppred>
This allows the user to specify the ppred binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to ppred (only useful with --usepb)

=item B<--pb_burn>

<default: 10>
This allows the user to specify the burn-in value used for the phylobayes analysis (only useful with --usepb)

=item B<--reps>

<default: 1000>
This is the number of datasets which will be generated according to the estimated parameters. This number represents the sample size of the distribution. Each dataset will be evaluated twice for a likelihood score, once with and once without the topology constrained. If using the SOWHat alternative, this is the number of test statistics that will be calculated, the number of times the parameters will be optimized, as well as the number of new alignments that will be generated.

=item B<--runs>
<default: 1>
This is the number of runs. 

=item B<--partition>

This can be a partition file which applies to the dataset. It must be in a format recognizable by RAxML version 7.7.0.

=item B<--rerun>

This option will adjust the SOWH test to account for variability in the maximum likelihood search. In this option, the test statistic and parameters will be recalculated for each alignment generated. The mean test statistic will then be tested against the null distribution using a one tailed test, similar to the SOWH test.

=item B<--restart>

This option allows the user to restart a test without reconstructing the null distribution. The final two iterations are removed to eliminate any trees not fully completed. The statistics will be parsed again from the output files of RAxML and the report will be calculated at each iteration.
=item B<--gaps>

This option will call a python script which propogates the undetermined sites in the original dataset into all simulated datasets before they are evaluted. This allows simulated data to more accurately reflect the real world data.

=item B<--debug>

do not redirect standard out and standard error. RAxML in particular will produce lots of output with this option. Can be useful for debugging problems like, for example, bad tree format.

=item B<--help>

Print this manual

=item B<--version>

Print the version. Overrides all other options.

=back

=head1 DESCRIPTION

This program automates the steps required for the SOWH test (as described by Goldman et. al., 2000. It depends on the freely available seq-gen and RAxML software packages. It works on amino acid, nucleotide, and binary character state datasets. Partitions can be specified. It can also use PhyloBayes to simulate the null distribution.

The program calculates the difference between two likelihood scores: that of the best tree, and the best tree constrained by the hypothesized topology. The maximum likelihodd analyses are run using RAxML, a phylogenetic tool written by Alexandros Stamatakis, and freely available under GNU GPL lisence. See:
https://github.com/stamatak/RAxML-Light-1.0.5

This program then generates new alignments based on the hypothesized topology and the maximum number of free parameters from the constrained topology, including branch lengths as well as the frequencies, transtition rates, and alpha values (if available, partitions are taken into account). These datasets are generated using seq-gen, written by Andrew Rambaut and Nick C. Grassly. It is freely available under BSD license, see: 
http://tree.bio.ed.ac.uk/software/seqgen/

The program then calculates the likelihood scores of each of these alignments both with and without the topology constrained according to the hypothesis. The differences between these scores become the distributions against which the test value will be evaluated.

+The p-value of the test statistic is calculated using R, using the pnorm function. Information about the test is printed to the file sowhat.results in the directory specified by the user. The variance of the null distribution is printed to variance.eps.

R is freely available under the GPL-2 license.

Nick Goldman, Jon P. Anderson, and Allen G. Rodrigo
Likelihood-Based Tests of Topologies in Phylogenetics
Syst Biol (2000) 49 (4): 652-670 doi:10.1080/106351500750049752

Here is an example command using the test datasets:

=over 2

perl sowhat ...

=back

=head1 BUGS

Please report them to any or all of the authors.

=head1 COPYRIGHT

Copyright (C) 2012,2013 Samuel H. Church, Joseph F. Ryan, Casey W. Dunn

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
