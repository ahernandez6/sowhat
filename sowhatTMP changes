#!perl 

#    sowhat - SOWH test 
#        (likelihood-based test used to compare tree topologies which
#         are not specified a priori)
#
#    Copyright (C) 2013  Samuel H. Church, Joseph F. Ryan, Casey W. Dunn
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

our $VERSION = 0.20;

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Path;
use File::Temp;
use Data::Dumper;
use Cwd;
#use local lib if installing Statistics::R without sudo cpan
#use local::lib;
use Statistics::R;

our $RAX = 'raxmlHPC';
our $GARLI = 'garli';
our $SEQGEN = 'seq-gen';
our $PB = 'pb -f';
our $PPRED = 'ppred';
our $PB_SAMPLING_FREQ = 5;
our $PB_SAVING_FREQ   = 1;
our $PB_BURN   = 10;
our $DEFAULT_REPS = 1000;
our $DEFAULT_RUNS = 1;
our $QUIET = 1;
our $DIR = '';
our $SCRATCH = '';
our $FREQ_BIN_NUMBER = 10;
our $TRE_PREFIX = 'RAxML_bestTree';
our $NEW_PARTITION_FILE = 'new.part.txt';
our $PART_RATE_MATRIX_PREFIX = 'RAxML_proteinGTRmodel';
our $NAME = '';
our $SUBZERO = 0.001;

MAIN: {
    my $rh_opts = process_options();
    my $ver = '';
    if ($rh_opts->{'usegarli'}) {
        $ver = $rh_opts->{'garli_version'};
    } else {
        $ver = get_version();
    }

    my $alns_to_gen = 1;
    my (@delta_dist,@deltaprime_dist,@mean,@var,@stdev,@rse,@ks); 
    my (@current_score,@pen_score,@ratio_mean,@ratio_var,@ratio_stdev,@ratio_rse,@ratio_count);
    my (@perc_ratio,@mc_count,@pval_mc);
    my $ra_params = [];
    my $ra_recalc_flag = [];
    my $ra_alns = [];
    my $ra_rates = [];
    my $ra_aln_len = [];
    my $restart_num = restart($rh_opts);
    print_initial_messages($rh_opts);
    
    for (my $ts = 0; $ts < $rh_opts->{'reps'}; $ts++) {
    #LOOP: For the number of repetitions, simulate data
    #      and calculate the statistics.

        for (my $ch = 0; $ch < $rh_opts->{'runs'}; $ch++) {
        #LOOP: For the number of runs, perform each repetition of the test.
        #      This loop allows multiple runs to be performed simultaneously.

            my $codon_flag = 0;
            my $tag = "$ch.$ts";
            
            my $restart_flag = 0;
            if (($rh_opts->{'restart'}) && ($ts <= $restart_num)) {
                $restart_flag = 1;
            }

            my ($best_ml,$best_t1,$rh_stats,$ra_diff,$fd_file);

            if (($ts < 1) || ($rh_opts->{'rerun'})) {
            #For the first iteration of each run only, run the initial trees
            #and get the parameter values.
                run_initial_trees($rh_opts,$restart_flag,$tag);
                if ($rh_opts->{'usepb'}) {
                    get_params_w_pb($rh_opts,$alns_to_gen,$restart_flag,$tag);
                } else {
                    ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) = 
                    get_params($rh_opts,$restart_flag,$tag);
                }
            }

            if ($rh_opts->{'usepb'}) {
                $ra_alns = generate_alignments_w_pb($rh_opts,$alns_to_gen,
                $restart_flag,$tag);
            } else {
                $ra_alns = generate_alignments($ra_aln_len,$ra_params,
                $ra_rates,$rh_opts,$alns_to_gen,$restart_flag,$tag);
            }

            for (my $i = 0; $i < @{$ra_alns}; $i++) {
            #LOOP: For the number of alignments generated under this iteration,
            #      run both raxml trees and calculate the statistic.
            #      This loop is necessary when $alns_to_gen is >1

                run_gen_trees($ra_alns,$rh_opts,$ra_aln_len,
                              $codon_flag,$i,$restart_flag,$tag);

                ($best_ml,$best_t1,$rh_stats,$ra_diff,$fd_file) =
                evaluate_distribution($alns_to_gen,$rh_opts->{'name'},
                    $rh_opts->{'rerun'},\@delta_dist,\@deltaprime_dist,
                    \@mean,\@var,\@stdev,\@rse,\@ks,
                    \@current_score,\@pen_score,$i,$ts,$ch,$tag,$rh_opts);
            }

            if ($ch == ($rh_opts->{'runs'} - 1)) {
            #After a successive iteration on all runs, 
            #create a graph
                plot_runs(\@mean,$rh_opts->{'runs'},$ts) if ($ch);
            }

            if($ts > 9) {
            #After 10 iterations on all runs,
            # begin to calculate and report the statistics.
                calc_ratio($ch,$ts,\@current_score,\@pen_score,
                    \@ratio_mean,\@ratio_var,\@ratio_stdev,\@ratio_rse,
                    \@mean,\@var,\@stdev,\@rse,\@ks);
                print_report($ch,$ts,$best_ml,$best_t1,$rh_stats,$ra_diff,
                \@delta_dist,\@ratio_mean,\@ratio_var,\@ratio_stdev,\@ratio_rse,
                $rh_opts,$fd_file,\@ratio_count,\@perc_ratio,\@mc_count,\@pval_mc,$ver);
            } else {
                print "-";
            }
        }
    }
}

sub resort_freqs {
    my $freq_str = shift;
    my @fr = split /\s+/, $freq_str;
    my $str = "$fr[0] $fr[14] $fr[11] $fr[2] $fr[1] $fr[13] $fr[3] $fr[5] $fr[6] $fr[7] $fr[9] $fr[8] $fr[10] $fr[4] $fr[12] $fr[15] $fr[16] $fr[18] $fr[19] $fr[17] ";
    return $str;
}

#  IN: Garli-sorted rates
# OUT: Garli rates in an order for seq-gen
# garli rates are ordered differently than raxml and seq-gen so we
# need to resort them.
sub resort_rates {
    my $ra_r = shift;
    my %garli = ();
    my @resorted = ();
    my @aa = qw(A C D E F G H I K L M N P Q R S T V W Y);
    my $count = 0;
    for (my $i = 0; $i < @aa; $i++) {
        for (my $j = 0; $j < @aa; $j++) {
            next if ($i > $j);
            if ($i == $j) {
                $garli{$aa[$i]}->{$aa[$j]} = 0.0;
            } else {
                $garli{$aa[$i]}->{$aa[$j]} = $ra_r->[$count];
                $garli{$aa[$j]}->{$aa[$i]} = $ra_r->[$count];
                $count++;
            }
        }
    }
    my @rax_aa = qw(A R N D C Q E G H I L K M F P S T W Y V);
    my $rax_count = 0;
    for (my $i = 0; $i < @rax_aa; $i++) {
        for (my $j = 0; $j < @rax_aa; $j++) {
            $resorted[$i]->[$j] = $garli{$rax_aa[$i]}->{$rax_aa[$j]};
        }
        $rax_count++;
    }
    return \@resorted;
}

# IN: hashref with options
# OUT: none
# JOB: prints messages to user at beginning of run
sub print_initial_messages {
    my $rh_opts = shift;

    print "SOWHAT:\n";
    print "Results are being printed to $DIR" . "sowhat.results\n" unless($rh_opts->{'runs'} > 1);
    print "Number of runs = $rh_opts->{'runs'}. Details printed to $DIR" . "sowhat.runs.info\n" if($rh_opts->{'runs'} > 1);
    print "Results of each run printed to separate file: $DIR" . "sowhat.results.'run'\n" if($rh_opts->{'runs'} > 1);
    if (interleaved($rh_opts->{'aln'})) {
        die "your alignment $rh_opts->{'aln'} appears to be in phylip interleaved format or sequences are not on a single line. Sorry but sowhat cannot currently deal with this. Please convert to sequential or have one line per taxa.\n";
    }
    print "Sample: ";
}

sub interleaved {
    my $file = shift;
    open IN, $file or die "cannot open $file:$!";
    my $topline = <IN>;
    $topline =~ m/\s*(\d+)\s+(\d+)/;
    my $seq_num = $1;
    my $count = 0;
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*$/);
        $count++;
    }
    return 1 if ($count != $seq_num);
}

# IN:  none
# OUT: reference to a hash of command-line options
# JOB: checks and organizes all command-line options
sub process_options {
    my $rh_opts = {};
    $rh_opts->{'reps'} = $DEFAULT_REPS;
    $rh_opts->{'runs'} = $DEFAULT_RUNS;
    $rh_opts->{'orig_options'} = [@ARGV];
    $rh_opts->{'rax'} = $RAX;
    $rh_opts->{'seqgen'} = $SEQGEN;

    my $opt_results = Getopt::Long::GetOptions(
                                "aln=s" => \$rh_opts->{'aln'},
                         "constraint=s" => \$rh_opts->{'constraint_tree'},
                                "debug" => \$rh_opts->{'debug'},
                                "dir=s" => \$rh_opts->{'dir'},
                              "garli=s" => \$rh_opts->{'garli'},
                         "garli_conf=s" => \$rh_opts->{'garli_conf'},
                                 "help" => \$rh_opts->{'help'},
                                  "max" => \$rh_opts->{'max'},
                              "model=s" => \$rh_opts->{'mod'},
                               "name=s" => \$rh_opts->{'name'},
                               "nogaps" => \$rh_opts->{'nogaps'},
                          "partition=s" => \$rh_opts->{'part'},
                                 "pb=s" => \$rh_opts->{'pb'},
                            "pb_burn=i" => \$rh_opts->{'pb_burn'},
                              "ppred=s" => \$rh_opts->{'ppred'},
                                "rax=s" => \$rh_opts->{'rax'},
                               "reps=i" => \$rh_opts->{'reps'},
                                "rerun" => \$rh_opts->{'rerun'},
                              "restart" => \$rh_opts->{'restart'},
                               "runs=i" => \$rh_opts->{'runs'},
                             "seqgen=s" => \$rh_opts->{'seqgen'},
                                 "stop" => \$rh_opts->{'stop'},
                                "usepb" => \$rh_opts->{'usepb'},
                             "usegarli" => \$rh_opts->{'usegarli'},
                              "version" => \$rh_opts->{'version'},
                           );

    $PPRED = $rh_opts->{'ppred'} if ($rh_opts->{'ppred'});
    if ($rh_opts->{'usegarli'}) {
        $rh_opts->{'garli_conf'} or die "--garli_conf is required with --usegarli\n";
        if ($rh_opts->{'mod'}) {
            warn "  cannot use --model with --usegarli\n";
            die "  model should be supplied in conf file\n";
        }
        $GARLI = $rh_opts->{'garli'} if ($rh_opts->{'garli'});
        $rh_opts->{'garli_version'} = check_garli_version();
    }
    $PB = $rh_opts->{'pb'} if ($rh_opts->{'pb'});
    $PB_BURN = $rh_opts->{'pb_burn'} if ($rh_opts->{'pb_burn'});
    $RAX = $rh_opts->{'rax'} if ($rh_opts->{'rax'});
    $SEQGEN = $rh_opts->{'seqgen'} if ($rh_opts->{'seqgen'});
    $QUIET = 0 if ($rh_opts->{'debug'});
    die "$VERSION\n" if ($rh_opts->{'version'});
    pod2usage({-exitval => 0, -verbose => 2}) if $rh_opts->{'help'};
    if ($rh_opts->{'usegarli'}) {
        check_constraint_tree_for_operators($rh_opts->{'constraint_tree'});
        unless ($rh_opts->{'constraint_tree'} &&
                $rh_opts->{'aln'} &&
                $rh_opts->{'name'}) {
            warn "missing --constraint\n" unless ($rh_opts->{'constraint_tree'});
            warn "missing --aln\n" unless ($rh_opts->{'aln'});
            warn "missing --name\n" unless ($rh_opts->{'name'});
            usage();
        }
    } else {
        unless ($rh_opts->{'constraint_tree'} &&
            $rh_opts->{'aln'} &&
            $rh_opts->{'mod'} &&
            $rh_opts->{'name'}) {
            warn "missing --constraint\n" unless ($rh_opts->{'constraint_tree'});
            warn "missing --aln\n" unless ($rh_opts->{'aln'});
            warn "missing --name\n" unless ($rh_opts->{'name'});
            warn "missing --model\n" unless ($rh_opts->{'mod'});
        }
    }
    $NAME = $rh_opts->{'name'};
    set_out_dir($rh_opts->{'dir'});
    return $rh_opts;
}

sub check_constraint_tree_for_operators {
    my $tre = shift;
    open IN, $tre or die "cannot open $tre:$!";
    while (my $line = <IN>) {
        if ($line =~ m/^\s*\(/) {
            warn "error: garli constraint tree must start with '+' or '-'\n";
            warn "       for example: '+((1,3,5),2,4,6,7,8);\n";
            die "       see garli manual\n";
        } elsif ($line =~ m/^\s*\+/) {
            return 1;
        } elsif ($line =~ m/^\s*\-/) {
            return 1;
        }
    }
    warn "unexpected constraint tree: $tre\n";
    die "tree should look like: '+((1,3,5),2,4,6,7,8);'\n";
}

sub check_garli_version {
    my $errorcode = system "$GARLI -v";
    if ($errorcode != 0) {
        die "$GARLI is not in your path.\n  Supply full path to garli binary with --garli option\n    e.g., --garli=/usr/local/Garli-2.0-IntelOSX-multithread/bin/Garli-2.0\n";
    }
    my $version_st = `$GARLI -v`;
    my @lines= split /\n/, $version_st;
    my $numeric_version = '';
    my $version = '';
    my $possible_error = '';
    foreach my $l (@lines) {
        $possible_error .= $l;
        next unless $l =~ m/^GARLI\S* Version ((\d+\.\d+)\.(\d+)?)/;
        $version = $1;
        $numeric_version = $2;
        last;
    }
    if ($version eq '') {
        die "Error from GARLI (check --garli option):\n$possible_error";
    }
    if ($numeric_version < 2) {
        warn "sowhat ERROR:\n";
        warn "You are running version $version of GARLI\n";
        die  "sowhat requires version 2.0 or higher\n";
    }
    return $version;
}

# IN:  output directory specified with --dir on command-line
# OUT: none
# JOB: makes sure full path is used for output directory (required by RAX)
sub set_out_dir {
    my $opt_dir = shift;
    my $pwd = getcwd();
    if ($opt_dir) {
        $opt_dir = "$pwd/$opt_dir" if ($opt_dir !~ m/^\//);
        $opt_dir .= '/' if ($opt_dir !~ m/\/$/);
        $DIR = $opt_dir if ($opt_dir);
        $SCRATCH = "$DIR" . "sowhat_scratch/";
    } else {
        warn "missing --dir\n";
        usage();
    }
    File::Path::mkpath($DIR) unless (-d $DIR);
    File::Path::mkpath($SCRATCH) unless (-d $SCRATCH);
}

# IN:  system command (e.g., ls -l)
# OUT: none
# JOB: runs a commond, prints command if in verbose mode, or if command fails
sub safe_system {
    my $cmd = shift;
    warn "\$cmd = $cmd\n" unless ($QUIET);
    my $error = system $cmd;
    warn "system call failed:\n$cmd\nerror code=$?" if ($error != 0);
}

# IN: none
# OUT: returns version of raxml
# JOB: runs raxml -v and parses the output to check version,
#      throws an error if not correct version
sub get_version {
    my $version_st = `$RAX -v`;
    my @lines= split /\n/, $version_st;
    my $version = '';
    my $possible_error = '';
    foreach my $l (@lines) {
        $possible_error .= $l;
        next unless $l =~ m/^This is RAxML version (\d+\.\d+)/;
        $version = $1;
        last;
    }
    if ($version eq '') {
        die "Error from RAxML (check --rax option):\n$possible_error";
    }
    if ($version < 7.7) {
        warn "sowhat ERROR:\n";
        warn "You are running version $version of RAxML\n";
        die  "sowhat requires version 7.7 or higher\n";
    }
    return $version;
}

# IN: command-line options hash
# OUT: return flag for determining where to resume test
# JOB: identify the final two iterations, remove them, and signal 
#      where to resume the test
sub restart {
    my $rh_opts = shift;
    my $high_file_num = 0;
    my $num = 0;
    my $fileml = '';
    my $reps = $rh_opts->{'reps'};
    for (my $i = 0; $i < $reps; $i++) { 
        if($rh_opts->{'usegarli'}) {
            $fileml = "$SCRATCH" . "ml.0.$i.0.screen.log";
        } else {
            $fileml = "$SCRATCH" . "RAxML_info.ml.0.$i.0";
        }
        if (-e $fileml) {
            $high_file_num = $i;
        }
    }
    if($rh_opts->{'restart'} && $rh_opts->{'usegarli'}) {
        unlink glob "$SCRATCH/*0.$high_file_num.0*";
        $num = ($high_file_num - 1);
        unlink glob "$SCRATCH/*0.$num.0*";
        $num = ($high_file_num - 2);        
    } elsif($rh_opts->{'restart'}) {
        unlink glob "$SCRATCH/*0.$high_file_num.0*";
        $num = ($high_file_num - 1);
        unlink glob "$SCRATCH/*0.$num.0*";
        $num = ($high_file_num - 2);
    } elsif($high_file_num) {
        warn "    sowhat output files with that name already exist\n";
        die  "     use --restart if you want to pick up where you left off\n";
    } 
    return $num;
}

# IN:  command-line options hash
#      restart flag
#      string consisting of the current rep and run
# OUT: none
# JOB: formats options and runs trees using _run_best_tree method 
#      with and without the constraint tree
sub run_initial_trees {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;
    my $conf = $rh_opts->{'garli_conf'};
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $mod = $rh_opts->{'mod'};
    my $tre = $rh_opts->{'constraint_tree'};

    if ($rh_opts->{'usegarli'}) {
        _run_best_tree_w_garli('ml',$conf,$aln,0,$restart,$tag);
        _run_best_tree_w_garli('t1',$conf,$aln,0,$restart,$tag,$tre);
    } else {
        _run_best_tree_w_raxml('ml',$aln,$part,$mod,$restart,$tag);
        _run_best_tree_w_raxml('t1',$aln,$part,$mod,$restart,$tag,$tre);
    }
}

sub _run_best_tree_w_garli {
    my $title   = shift;
    my $conf    = shift;
    my $aln     = shift;
    my $max     = shift;
    my $restart = shift;
    my $tag     = shift;
    my $const   = shift;
    my ($fh,$file) = File::Temp::tempfile( SUFFIX => '.garli.conf',
                                   UNLINK => 1,
                                   DIR => $SCRATCH);
    open IN, $conf or die "cannot open $conf:$!";
    print $fh "datafname = $aln\n";
    print $fh "ofprefix = $SCRATCH/$title.$tag\n";
    print $fh "searchreps = 1\n";
    print $fh "outputphyliptree = 1\n";
    print $fh "collapsebranches = 0\n";
    if ($const) {
        print $fh "constraintfile = $const\n";
    }
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*outputphyliptree\s*=\s/i);
        next if ($line =~ m/^\s*datafname\s*=\s/i);
        next if ($line =~ m/^\s*constraintfile\s*=\s/i);
        next if ($line =~ m/^\s*ofprefix\s*=\s/i);
        next if ($line =~ m/^\s*collapsebranches\s*=\s/i);
        next if ($line =~ m/^\s*searchreps\s*=\s/i);
        if ($max) {
            if ($line =~ m/^\s*\[\s*model\s*[0-9.]+\s*\]/i) {
                print $fh $line;
                print $fh "statefrequencies = estimate\n";
                if ($max =~ m/DNAGARLI/i) {
                    print $fh "ratematrix = 6rate\n";
                } else {
                    print $fh "ratematrix = estimate\n";
                }
                
                print $fh "ratehetmodel = gamma\n";
                print $fh "invariantsites = estimate\n";
                next;
            }
            next if ($line =~ m/^\s*ratematrix\s*=\s/i);
            next if ($line =~ m/^\s*statefrequencies\s*=\s/i);
            next if ($line =~ m/^\s*ratehetmodel\s*=\s/i);
            next if ($line =~ m/^\s*invariantsites\s*=\s/i);
        }
        print $fh $line;
    }
    my $cmd = "$GARLI $file";
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN:  title          (-n for raxml)
#      alignment file (-s for raxml)
#      partition file (-q for raxml)
#      model          (-m for raxml)
#      restart flag
#      string consisting of the current rep and run (-n for raxml)
#      treefile       (-t for raxml)
# OUT: none
# JOB: format the command line for running raxml tree
#      only includes -q partitionfile or -t treefile if they are supplied     
sub _run_best_tree_w_raxml {
    my $title   = shift;
    my $aln     = shift;
    my $part    = shift;
    my $mod     = shift;
    my $restart = shift;
    my $tag     = shift;
    my $tre     = shift;

    my $cmd = "$RAX -f d -p 1234 -w $SCRATCH -m $mod -s $aln -n $title.$tag";
    $cmd .= " -q $part" if ($part);
    $cmd .= " -g $tre" if ($tre);
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN:  command-line options hash
#      replicates (number of trees to generate in phylobayes)
#      restart flag
#      string consisting of the current rep and run
# OUT: the id of the phylobayes run (used later by ppred)
# JOB: format command line for phylobayes and run phylobayes
sub get_params_w_pb {
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $id = "$SCRATCH" . $rh_opts->{'name'} . ".$tag";
    my $pb_reps = $reps * $PB_SAMPLING_FREQ + $PB_BURN;
    my $pb_cmd = "$PB -d $rh_opts->{'aln'} -T $rh_opts->{'constraint_tree'} ";
    $pb_cmd .= "-x $PB_SAVING_FREQ $pb_reps $id";
    if ($QUIET) {
        $pb_cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $pb_cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($pb_cmd) unless($restart);
}

# IN:  command-line options hash
#      replicates (number of trees to generate in phylobayes)
#      restart flag
#      string consisting of the current rep and run
#      id of the phylobayes run (output of get_params_w_pb method)
# OUT: array of file names of alignments
# JOB: format command-line options for ppred
#      run ppred
#      return alignment file names
sub generate_alignments_w_pb {
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $id = '';
    if ($rh_opts->{'recalc'}) {
        $id = "$SCRATCH" . $rh_opts->{'name'} . ".$tag"; 
    } else {
        $id = "$SCRATCH" . $rh_opts->{'name'} . ".0.0";
    }

    my @alns = ();
    my $ppred_cmd = "$PPRED -x $PB_BURN $PB_SAMPLING_FREQ $id";

    if ($QUIET) {
        $ppred_cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $ppred_cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($ppred_cmd) unless($restart);
    for (my $i = 0; $i < $reps; $i++) {
        push @alns, "${id}_sample_${i}.ali"; 
    }
    return \@alns;
}

# IN: command-line options hash
#     restart flag
#     string consistent of rep and run
# OUT: alignment length
#      flag for partitions by codon positions
#      array of parameter values
#      array of rates
# JOB: based on the model, uses one of four methods to parse params.
sub get_params {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;
    my $mod = $rh_opts->{'mod'};
    my $ra_aln_len = ();
    my $codon_flag = 0;
    my $ra_params = ();
    my $ra_rates = ();

    if ($rh_opts->{'usegarli'}) {
        my ($datatype,$model) = _parse_info_from_garli_conf($rh_opts->{'garli_conf'});
        $rh_opts->{'mod'} = $model;

        if ($datatype eq 'nucleotide') {
            my $type = 'DNA';
            ($ra_aln_len,$codon_flag,$ra_params) = _model_garli_nt($rh_opts,$type,$restart,$tag);
        } elsif ($datatype eq 'aminoacid') {
            my $type = 'AA';
            ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) = _model_garli_aa($rh_opts,$type,$restart,$tag);
        } else {
            warn "   sowhat only accepts 'nucleotide' or 'aminoacid' as datatype.";
            die  "    In your conf file ($rh_opts->{'garli_conf'}) you provided $datatype\n";
        }

    } elsif ($mod =~ m/^ASC/i) {
        die("RAxML models beginning with ASC are not currenlty supported by sowhat");
    } elsif ($mod =~ m/^BIN/i) {
        die("for binary character datasets, use MULTI models ...");
    } elsif ($mod =~ m/^(ASC_)?GTR/i) {
        ($ra_aln_len,$codon_flag,$ra_params) = _model_gtrgamma($rh_opts,$restart,$tag);
    } elsif ($mod =~ m/PROT/i) {
        ($ra_aln_len,$codon_flag,$ra_params,$ra_rates) = _model_prot($rh_opts,$restart,$tag);
    } elsif ($mod =~ m/MULTI/i) {
        ($ra_aln_len,$codon_flag,$ra_params) = _model_character_data($rh_opts,$restart,$tag);
    } else {
        die("model not recognized by sowhat. Full list of models: ...");
    }

    return ($ra_aln_len,$codon_flag,$ra_params,$ra_rates);
}


sub _parse_info_from_garli_conf {
    my $conf     = shift;
    my $datatype = '';
    my $model = '';
    my $rate = '';
    my $sfreq = '';
    my $het = '';
    my $invar = '';    
    open IN, $conf or die "cannot open $conf:$!";
    while (my $line = <IN>) {
        if ($line =~ m/^\s*datatype\s*=\s*(\S+)\s*/i) {
            my $dt = $1;
            $datatype = lc($dt);
        } elsif ($line =~ m/^\s*ratematrix\s*=\s*(\S+)\s*/i) {
            my $ratematrix = $1;
            $rate = lc($ratematrix);
        } elsif ($line =~ m/^\s*statefrequencies\s*=\s*(\S+)\s*/i) {
            my $statefrequencies = $1;
            $sfreq = lc($statefrequencies);
        } elsif ($line =~ m/^\s*invariantsites\s*=\s*(\S+)\s*/i) {
            my $invariantsites = $1;
            $invar = lc($invariantsites);
        } elsif ($line =~ m/^\s*ratehetmodel\s*=\s*(\S+)\s*/i) {
            my $ratehetmodel= $1;
            $het = lc($ratehetmodel);
        }
        next;
    }
    if ($sfreq =~ m/estimate/i && $het =~ m/gamma/i &&  $invar =~ m/estimate/i) {
        if ($rate =~ m/6rate/i) {
            $model = 'DNAGARLI';
        } elsif ($rate =~ m/estimate/i) {
            $model = 'AAGARLI';
        } else {
            $model = "$rate";
        }
    } else {
        $model = "$rate";
    }
    return ($datatype,$model);
}

sub _model_garli_nt {
    my $rh_opts = shift;
    my $datatype = shift;
    my $restart = shift;
    my $tag = shift;
    my $ra_params = [];
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $tre = $rh_opts->{'tre'};
    my $conf = $rh_opts->{'garli_conf'};
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,0);
    if ($rh_opts->{'mod'} =~ m/DNAGARLI/i) {
        $ra_params = _get_params_from_garli_nt("$SCRATCH" . "t1.$tag.screen.log",$datatype);
    } elsif ($rh_opts->{'max'}) {
        my $max_model = 'DNAGARLI';
        _run_best_tree_w_garli('par',$conf,$aln,$max_model,$restart,$tag,$tre);
        $ra_params = _get_params_from_garli_nt("$SCRATCH" . "par.$tag.screen.log",$datatype);
    } else {
        $ra_params = _get_params_from_garli_nt("$SCRATCH" . "t1.$tag.screen.log",$datatype);
    }
    return ($ra_aln_len,$codon_flag,$ra_params);
}

sub _model_garli_aa {
    my $rh_opts = shift;
    my $datatype = shift;
    my $restart = shift;
    my $tag = shift;
    my $ra_params = [];
    my $ra_rates = [];
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $tre = $rh_opts->{'tre'};
    my $conf = $rh_opts->{'garli_conf'};
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,0);
    if ($rh_opts->{'mod'} =~ m/AAGARLI/i) {
        ($ra_params,$ra_rates) = _get_params_from_garli_aa("$SCRATCH" . "t1.$tag.screen.log",$datatype);
    } elsif ($rh_opts->{'max'}) {
        my $max_model = 'AAGARLI';
        _run_best_tree_w_garli('par',$conf,$aln,$max_model,$restart,$tag,$tre);
        ($ra_params,$ra_rates) = _get_params_from_garli_aa("$SCRATCH" . "par.$tag.screen.log",$datatype);
    } else {
        ($ra_params,$ra_rates) = _get_params_from_garli_aa("$SCRATCH" . "t1.$tag.screen.log",$datatype);
    }
    return ($ra_aln_len,$codon_flag,$ra_params,$ra_rates);
}

sub _get_params_from_garli_nt {
    my $file = shift;
    my $datatype = shift;
    my %params = ();
    $params{'type'} = $datatype;
    open IN, $file or die "$file:$!";
    my $flag = 0;
    while (my $line = <IN>) {
        if ($line =~ m/Parameter estimates/) {
            $flag = 1;
        } elsif ($flag == 1) {
            $flag = 2;
        } elsif ($flag == 2) {
            die "unexpected garli log:$line " unless ($line =~ m/^rep 1:/);
            $line =~ s/^rep 1:\s+//;
            my @fs = split /\s+/, $line;
            die "unexpected # of elements:@fs " unless (scalar(@fs) == 12);
            $params{'rates'}->{'ac'} = $fs[0];
            $params{'rates'}->{'ag'} = $fs[1];
            $params{'rates'}->{'at'} = $fs[2];
            $params{'rates'}->{'ct'} = $fs[3];
            $params{'rates'}->{'cg'} = $fs[4];
            $params{'rates'}->{'gt'} = $fs[5];
            $params{'freqs'} = "$fs[6] $fs[7] $fs[8] $fs[9] ";
            $params{'alpha'} = $fs[10];
            $params{'pinv'} = $fs[11];
            $flag = 0;
        }
    }
    return ([\%params]);
}

sub _get_params_from_garli_aa {
    my $file = shift;
    my $datatype = shift;
    my $flag = 0;
    my %params = ();
    $params{'type'} = $datatype;
    my @rates = ();
    open IN, $file or die "$file:$!";
    while (my $line = <IN>) {
        if ($line =~ m/Equilibrium State Frequencies/) {
            $flag++;
        } elsif ($flag == 2) {
            $flag = 3;
        } elsif ($flag == 3) {
            if ($line =~ m/Rate Heterogeneity Model/) {
                $flag = 4;
            } else {
                $line =~ s/^\s+//;
                my @fs = split /\s+/, $line;
                $params{'freqs'} .= "$fs[0] $fs[1] $fs[2] $fs[3] $fs[4] ";
            }
        } elsif ($flag == 4 && $line =~ m/Parameter estimates/) {
            $flag = 5;
        } elsif ($flag == 5) {
            $flag = 6;
        } elsif ($flag == 6) {
            die "unexpected garli log:$line " unless ($line =~ m/^rep 1:/);
            $line =~ s/^rep 1:\s+//;
            my @fs = split /\s+/, $line;
            $params{'pinv'}  = pop @fs;
            $params{'alpha'} = pop @fs;
            if (scalar(@fs) >= 190) {
                my @garli_rates = @fs[0..189];
                @rates = @garli_rates;
                @rates = resort_rates(\@garli_rates);
            }
            $flag = 0;
        }
    }
    $params{'freqs'} = resort_freqs($params{'freqs'});
    # weird array of params is because
    # if this were partitioned we would have multiple params and rates
    return ([\%params],\@rates);
}

# IN: alignment file
#     partition file
#     restart flag
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
# JOB: gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_gtrgamma {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;
    my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
    my $ra_params = [];
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $tre = $rh_opts->{'tre'};
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    if ($rh_opts->{'mod'} =~ m/GTRGAMMAX/i) {
        $ra_params = _get_params_from_const_rax("$SCRATCH" . "RAxML_info.t1.$tag");
    } elsif ($rh_opts->{'max'}) {
        if ($part) {
            my $ra_part_names = _make_unlinked_partition_file($part,'DNAX',$new_part);
            _run_best_tree_w_raxml('par',$aln,$new_part,'GTRGAMMAX',$restart,$tag,$tre);
        } else {
            _run_best_tree_w_raxml('par',$aln,$part,'GTRGAMMAX',$restart,$tag,$tre);
        }
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.par.$tag");
    } else {
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    }
    return ($ra_aln_len,$codon_flag,$ra_params);
}

# IN: alignment file
#     partition file
#     restart flag
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
#      array of rates
# JOB: if partitioned, makes new part file using _make_unlinked_partition_file
#      run tree using the unlinked GTR model of raxml using _run_best_tree
#      gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_prot {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;
    my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
    my $ra_params = [];
    my $ra_rates = [];
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $tre = $rh_opts->{'tre'};
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    if ($rh_opts->{'mod'} =~ m/PROTGAMMAGTR_UNLINKED/i) {
        if ($part) {
            my $ra_part_names = _make_unlinked_partition_file($part,'GTR_UNLINKED',$new_part);
            $ra_rates = _parse_rates($tag,'t1',$ra_part_names);
        } else {
            $ra_rates = _parse_rates($tag,'t1');
        }
    } elsif ($rh_opts->{'max'}) {
        if ($part) {
            my $ra_part_names = _make_unlinked_partition_file($part,'GTR_UNLINKED',$new_part);
            _run_best_tree_w_raxml('par',$aln,$new_part,'PROTGAMMAGTR_UNLINKED',$restart,$tag,$tre);
            $ra_rates = _parse_rates($tag,'par',$ra_part_names);
        } else {
            _run_best_tree_w_raxml('par',$aln,$part,'PROTGAMMAGTR_UNLINKED',$restart,$tag,$tre);
            $ra_rates = _parse_rates($tag,'par');
        }
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.par.$tag");
    } elsif ($rh_opts->{'mod'} =~ /GTR/) {
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
        $ra_rates = _parse_rates($tag,'t1');
    } else {
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    }
    return ($ra_aln_len,$codon_flag,$ra_params,$ra_rates);
}

# IN: alignment file
#     partition file
#     restart flag
#     tree file
#     string consisting of rep and run
# OUT: alignment length
#      flag for partitions by codon position
#      array of parameter values
# JOB: gets part lengths using the _get_partition_lengths method
#      gets parameters using the _get_params_from_const_rax method
sub _model_character_data {
    my $rh_opts = shift;
    my $restart = shift;
    my $tag = shift;    
    my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
    my $ra_params = [];
    my $aln = $rh_opts->{'aln'};
    my $part = $rh_opts->{'part'};
    my $tre = $rh_opts->{'tre'};
    my ($ra_aln_len,$codon_flag) = _get_partition_lengths($aln,$part);
    if ($rh_opts->{'mod'} =~ m/MULTIGAMMAX/i) {
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    } elsif ($rh_opts->{'max'}) {
        _run_best_tree_w_raxml('par',$aln,$part,'MULTIGAMMAX',$restart,$tag,$tre);
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.par.$tag");
    } else {
        $ra_params = _get_params_from_const_rax("$SCRATCH" ."RAxML_info.t1.$tag");
    }
    return ($ra_aln_len,$codon_flag,$ra_params);
}

# IN: alignment file
#     partition file
# OUT: array of lengths
#      flag for partitions by codon position
# JOB: if partitioning scheme included
#      return the length of each partition for data
#      to be simulated separately
sub _get_partition_lengths {
    my $aln = shift;
    my $part = shift;
    my $codon_flag = 0;
    my @lens = ();
    if ($part) {
        open IN, $part or _my_die("cannot open $part:$!");
        while (my $line = <IN>) {
            chomp $line;
            next if ($line =~ m/^\s*$/);
            if ($line =~ m/^[^,]+,\s*\S+\s*=\s*(\d+)-(\d+)\s*$/) {
                my $len = ($2 - $1 + 1);
                push @lens, $len;
            } elsif ($line =~ m/^[^,]+,\s*\S+\s*=\s*(\d+)-(\d+)\S(\d+)\s*$/) {
                my $len = ($2 - $1)/$3 + 1;
                push @lens, $len;
                $codon_flag = 1;
            } else {
                _my_die("unexpected line in $part");
            }
        }
    } else {
        open IN, $aln or _my_die("cannot open $aln:$!");
        my $line = <IN>;
        if ($line =~ m/^\s*\d+\s+(\d+)\s*$/) {
            @lens = $1;
        } else {
            _my_die("Alignment file should be in PHYLIP format\n");
        }
    }
    return (\@lens,$codon_flag);
}

# IN: filename
# OUT: array of parameter values
# JOB: parse the base freq., alpha value, rates, and data type
sub _get_params_from_const_rax {
    my $model = '';
    my $file = shift;
    my @data = ();
    open IN, "$file" or die "cannot open $file:$!";
    my $part_num = 0;
    my @fields = ();
    my $lflag = 0;
    while (my $line = <IN>) {
        if ($line =~ m/^Partition: (\d+) with .*/) {
           $part_num = $1;
           next;
        } if ($line =~ m/^Base frequencies: (.*)/) {
            $data[$part_num]->{'freqs'}  = $1;
        } if ($line =~ m/^alpha\[/) {
            @fields = split/alpha/, $line;
            foreach my $f (@fields) {
                if ($f =~ m/^\[(\d+)\]: ([0-9.]+)( invar\[\d+\]: ([0-9.]+))?( rates\[\d+\] ([^:]+): ([0-9.\s]+))?(\s?ML estimate base freqs\[\d+\]: ((([0-9.]+)\s)+))?/) {
                    $part_num = $1;
                    $data[$part_num]->{'alpha'} = $2;
                    my $invar1 = $4;
                    my $rate1 = $6;
                    my $rate2 = $7;
                    my $freq1 = $9;
                    next unless ($invar1||$rate1||$freq1);
                    if ($invar1) {
                        $data[$part_num]->{'pinv'} = $invar1;
                    }
                    if ($rate1) {
                        my @code  = split /\s+/, $rate1;
                        my @rates = split /\s+/, $rate2;
                        for (my $i = 0; $i < @code; $i++) {
                            $data[$part_num]->{'rates'}->{$code[$i]} = $rates[$i];
                        }
                    }
                    if ($freq1) {
                        $data[$part_num]->{'freqs'} = "$freq1";
                    }
                }
            }
        } elsif ($line =~ m/^Partition: (\d+)\s*$/) {
            $lflag = $1 + 1;
        } elsif ($lflag) {
            if ($line =~ m/^Alignment Patterns: /) {
                next;
            } elsif ($line =~ m/^Name: /) {
                next;
            } elsif ($line =~ m/DataType: (\S+)/) {
                $data[$lflag - 1]->{'type'} = $1;
                $lflag = 0;
            } else {
                _my_die("unexpected line: $line");
            }
        }
    }
    return \@data;
} 

# IN: partition file
# OUT: number and lengths of partitions
#      name of partitions
# JOB: get partition lengths and names for new file
sub _make_unlinked_partition_file {
    my $part = shift;
    my $model = shift;
    my $new_part = shift;
    my ($ra_aa_part_ranges,$ra_part_names) = _get_aa_part_info($part);
    _print_unlinked_part($ra_aa_part_ranges,$model,$new_part);
    return $ra_part_names;
}

# IN: partition file
# OUT: number and lengths of partitions
#      name of partitions
# JOB: get partition lengths and names for new file
sub _get_aa_part_info {
    my $part = shift;
    open IN, $part or _my_die("cannot open $part:$!");
    my @fields = ();
    my @part_info = ();
    my @names = ();
    while (my $line = <IN>) {
        chomp $line;
        next if ($line =~ m/^\s*$/);
        @fields = split/\,/, $line;
        $fields[1] or _my_die("unexpected line in part file:$line\nexpecting comma");
        push @part_info, $fields[1];
        my @name_range = split /=/, $fields[1];
        $name_range[1] or _my_die("unexpected line in part file:$line\nexpecting =");
        $name_range[0] =~ s/\s//g;
        push @names, $name_range[0];
   }
   return (\@part_info,\@names);
}

# IN: partition info
#     new part file name
# OUT: none
# JOB: print new paritition info with the GTR_UNLINKED model
#      necessary for amino acid data
sub _print_unlinked_part {
    my $part_info = shift;
    my $model = shift;
    my $new_part = shift;
    open OUT, ">$new_part" or _my_die("cannot open $new_part:$!");
    for (my $i = 0; $i < @{$part_info}; $i++) {
       print OUT "$model," . "$part_info->[$i]\n";
    }
}

# IN: string consisting of rep and run
#     array of partition names
# OUT: array of rates for AA data
# JOB: Get rate matrix for AA data from raxml partition reports
sub _parse_rates {
    my $tag = shift;
    my $par_or_t1 = shift;
    my $ra_part_names = shift;
    my @rates = ();
    if ($ra_part_names) {
        foreach my $pn (@{$ra_part_names}) {
            my @local_rates = ();
            my $matrix = "$SCRATCH" . $PART_RATE_MATRIX_PREFIX . ".$par_or_t1.$tag" . "_Partition_" . $pn;
            open IN, "$matrix" or _my_die("cannot open $matrix:$!");
            while (my $line = <IN>) {
                my @fields = split/\s/, $line;
                push @local_rates, \@fields;
            }
            push @rates, \@local_rates;
        }
    } else {
        my $matrix = "$SCRATCH" . $PART_RATE_MATRIX_PREFIX . ".$par_or_t1.$tag" . "_Partition_No Name Provided";
        open IN, "$matrix" or _my_die("cannot open $matrix:$!");
        while (my $line = <IN>) {
            my @fields = split/\s/, $line;
            push @{$rates[0]}, \@fields;
        }
    }
    return \@rates;
}

# IN: array of alignment lengths
#     array of parameter values
#     array of transtition rates
#     command line options hash
#     number of reps to be completed
#     restart flag
#     string consisting of run and rep
# OUT: none
# JOB: run seqgen
#      parse the simulated datasets
#      build the alignment files
sub generate_alignments {
    my $ra_aln_len = shift;
    my $ra_params = shift;
    my $ra_rates = shift;
    my $rh_opts = shift;
    my $reps = shift;
    my $restart = shift;
    my $tag = shift;
    my $gapflag = $rh_opts->{'nogaps'};
    my $aln = $rh_opts->{'aln'};

    _run_seqgen($rh_opts,$ra_aln_len,$ra_params,$ra_rates,$reps,$restart,$tag);
    my $ra_ds = _build_datasets(scalar(@{$ra_params}),$aln,$gapflag,$tag);
    my $ra_alns = _make_alns($ra_ds,$aln,$tag);
}

# IN: opts hash
#     array of alignment lengths
#     array of parameter values
#     array of transition rates
#     number of reps (datasets to generate)
#     restart flag
#     string consisting of rep and run
# OUT: none
# JOB: build a command for seqgen based on number of separate 
#          parameter sets (partitions)
#      use model to determine parameter type
#      if recal model, add additional count number to tag
#      run seqgen
#      if binary data, convert data type in simulated datasets
sub _run_seqgen {
    my $rh_opts    = shift;
    my $ra_part_lens = shift;
    my $ra_params = shift;
    my $ra_rates  = shift;
    my $reps      = shift;
    my $restart   = shift;
    my $tag       = shift;
    my $count     = 0;
    my $recalc    = $rh_opts->{'rerun'};
    for (my $i = 0; $i < @{$ra_params}; $i++) {
        my $rh_part = $ra_params->[$i];
        my $cmd = "$SEQGEN -or ";
        $cmd .= "-l$ra_part_lens->[$i] ";
        $cmd .= "-a$rh_part->{'alpha'} ";
        $cmd .= "-n$reps ";
        if ($rh_part->{'type'} eq 'DNA') {
            $cmd .= "-mGTR ";
            $cmd .= _get_dna_params($rh_part);
        } elsif ($rh_part->{'type'} eq 'AA') {
            if (scalar(@{$ra_rates})) {
                $cmd .= "-mGENERAL ";
                $cmd .= _get_aa_params($rh_part,$ra_rates->[$i]);
            } else {
                my $trans_model = _translate_model($rh_opts);
                $cmd .= "-m$trans_model ";
                $cmd .= _get_aa_params($rh_part,0);
            }
        } elsif ($rh_part->{'type'} eq 'Multi-State') {
            $cmd .= "-mGTR ";
            $cmd .= _get_char_params($rh_part);
        } else {
            _my_die(qq~do not know how to handle type: "$rh_part->{'type'}"\n~);
        }
        my $tre = "$TRE_PREFIX.t1.0.0";
         
        if ($recalc && $rh_opts->{'usegarli'}) {
            $tre = "t1.$tag.best.phy";
        } elsif ($recalc) {
            $tre = "$TRE_PREFIX.t1.$tag";
        } elsif ($rh_opts->{'usegarli'}) {
            $tre = 't1.0.0.best.phy';
        }

        $cmd .= " < $SCRATCH" . "$tre > $SCRATCH" . "seqgen.out.$tag.$count";
        $cmd .= " 2>> ${DIR}sowh_stderr_$NAME.txt" if ($QUIET);
        $count++;
        safe_system($cmd) unless($restart);
        if ($rh_part->{'type'} eq 'Multi-State') {
            my $file = "seqgen.out.$tag." . ($count - 1);
            _convert_AT_to_01("$SCRATCH" . $file, $ra_part_lens->[$i]);
        }
    }
}

sub _translate_model {
    my $rh_opts = shift;
    my $mod = $rh_opts->{'mod'};
    $mod = uc($mod);
    my $core_mod = 0;
    if ($rh_opts->{'usegarli'}) {
        $core_mod = $mod;
        if ($core_mod =~ m/JONES/) {
            return 'JTT';
        } elsif ($core_mod =~ m/WAG/) {
            return 'WAG';
        } elsif ($core_mod =~ m/DAYHOFF/) {
            return 'PAM';
        } elsif ($core_mod =~ m/MTREV/) {
            return 'MTREV';
        } elsif ($core_mod =~ m/MTMAM/) {
            return 'MTMAM';
        } else {
            warn "you specified $mod. garli does not allow $mod\n";
            warn "    either run: jones WAG dayhoff mtREV mtmam\n";
            die  "    or specify --max\n";
        }
    }
    elsif ($mod =~ m/(?:ASC_)?PROT(?:GAMMA|CAT)(\S+)/) {
        $core_mod = $1;
        if ($core_mod =~ m/JTT/) {
            return 'JTT';
        } elsif ($core_mod =~ m/WAG/) {
            return 'WAG';
        } elsif ($core_mod =~ m/DAYHOFF/) {
            return 'PAM';
        } elsif ($core_mod =~ m/BLOSUM62/) {
            return 'BLOSUM';
        } elsif ($core_mod =~ m/MTREV/) {
            return 'MTREV';
        } elsif ($core_mod =~ m/MTART/) {
            return 'MTART';
        } elsif ($core_mod =~ m/CPREV45/) {
            return 'CPREV';
        } else {
            warn "you specified $mod. seq-gen does not know about $core_mod\n";
            warn "    either run: WAG DAYHOFF BLOSUM62 MTREV MTART CPREV45\n";
            die  "    or specify --max\n";
        }
    } else {
        die "unexpected model: $mod\n";
    }
}

# IN: parameter values
# OUT: seqgen command components
# JOB: build command based on DNA model
sub _get_dna_params {
    my $rh_part = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    _my_die("unexpected rate") unless ($rh_part->{'rates'}->{'ac'} &&
          $rh_part->{'rates'}->{'ag'} && $rh_part->{'rates'}->{'ct'} &&
          $rh_part->{'rates'}->{'cg'} && $rh_part->{'rates'}->{'at'} &&
          $rh_part->{'rates'}->{'gt'} );
    $cmd .= "-f$rh_part->{'freqs'} ";
    $cmd .= "-r$rh_part->{'rates'}->{'ac'} $rh_part->{'rates'}->{'ag'} ";
    $cmd .= "$rh_part->{'rates'}->{'at'} $rh_part->{'rates'}->{'cg'} ";
    $cmd .= "$rh_part->{'rates'}->{'ct'} $rh_part->{'rates'}->{'gt'} ";
    return $cmd;
}

# IN: parameter values
#     rate matrix for dataset
# OUT: seqgen command components
# JOB: build command based on amino acid model
sub _get_aa_params {
    my $rh_part = shift;
    my $ra_r = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    $cmd .= "-f$rh_part->{'freqs'} ";
    my $j = 0;
    if ($ra_r != 0) {
        $cmd .= "-r";
        for (my $i = 0; $i < 20; $i++) {
            $j++;
            for (my $k = $j; $k < 20; $k++) {
                $cmd .= "$ra_r->[$i]->[$k], ";
            }
        }
        _my_die("unexpected rates") unless (scalar(@{$ra_r}) == 21);
    }
    return $cmd;
}

# IN: parameter values
# OUT: seqgen command components
# JOB: build command based on binary character model
sub _get_char_params {
    my $rh_part = shift;
    my $cmd = '';
    _my_die("unexpected freq") unless ($rh_part->{'freqs'});
    $rh_part->{'freqs'} =~ s/^\s*//;
    $rh_part->{'freqs'} =~ s/\s*$//;
    my @freqs = split /\s+/, $rh_part->{'freqs'};
    unless (scalar(@freqs) == 2) {
        _my_die("expecting 2 frequencies. Multi-State only works w/binary matrix\n");
    }
    $cmd .= "-f$freqs[0],0.0,0.0,$freqs[1] ";
    return $cmd;
}

# IN: filename of simulated dataset
#     partition lengths
# OUT: none
# JOB: change simulated data from AT to 01 (nucleotide to binary)
sub _convert_AT_to_01 {
    my $file  = shift;
    my $num_cols = shift;
    my $updated = '';
    open IN, $file or _my_die("cannot open $file:$!");
    while (my $line = <IN>) {
        chomp $line;
        if ($line =~ m/^(\S+\s+)(\S+)$/) {
            my $id = $1;
            my $seq = $2;
            if (length($seq) == $num_cols) {
                $seq =~ tr/AT/01/;
                $updated .= "$id$seq\n";
            } else {
                $updated .= "$line\n";
            }
        } else {
            $updated .= "$line\n";
        }
    }
    close IN;
    open OUT, ">$file" or _my_die("cannot open >$file:$!");
    print OUT $updated;
    close OUT;
}

# IN: number of separater parameter sets (partitions)
#     string consisting of rep and run
# OUT: array of simulated data
# JOB: parse titles and data
#      build alignment files
sub _build_datasets {
    my $num = shift;
    my $aln = shift;
    my $gapflag = shift;
    my $tag = shift;
    my @allseqs = ();
    my $ra_ids = _get_ids_from_seqgen_out("$SCRATCH" . "seqgen.out.$tag.0");
    for (my $i = 0; $i < $num; $i++) {
        my $ra_seqs = _get_seqs_from_seqgen_out("$SCRATCH" . "seqgen.out.$tag.$i");
        push @allseqs, $ra_seqs;
    }
    my $ra_ds = _make_datasets_from_allseqs($ra_ids,$aln,$gapflag,\@allseqs);
    return $ra_ds;
}

# IN: filename of first simulated dataset
# OUT: array of taxa titles
# JOB: parse taxa titles
sub _get_ids_from_seqgen_out {
    my $file = shift;
    my @ids = ();
    open IN, $file or _my_die("cannot open $file:$!");
    my $topline = <IN>;
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*$/);
        last if ($line eq $topline);
        my @fields = split /\s+/, $line;
        push @ids, $fields[0];
    }
    return \@ids;
}

# IN: filename of each simulated dataset
# OUT: array of simulated data
# JOB: parse simulated data
sub _get_seqs_from_seqgen_out {
    my $file = shift;
    my @seqs = ();
    open IN, $file or _my_die("cannot open $file:$!");
    my $topline = <IN>;
    my $count = 0;
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*$/);
        if ($line eq $topline) {
            $count++;
            next;
        }
        chomp $line;
        my @fields = split /\s+/, $line;
        push @{$seqs[$count]}, $fields[1];
    }
    return \@seqs;
}

# IN: array of taxa titles
#     alignment file
#     flag for gap simulation
#     array of simulated data
# OUT: array of formatted alignment file content
# JOB: concatenate data, format for alignment files
#      if nogaps option, do not stencil gaps in seqs
sub _make_datasets_from_allseqs {
    my $ra_ids = shift;
    my $real_aln = shift;
    my $gapflag = shift;
    my $ra_all = shift;
    my @ds = ();
    foreach my $ra_seqs (@{$ra_all}) {
        for (my $i = 0; $i < @{$ra_seqs}; $i++) {
            for (my $j = 0; $j < @{$ra_ids}; $j++) {
                 $ds[$i]->[$j] .= "$ra_seqs->[$i]->[$j]";
            }
        }
    }
    unless ($gapflag) {
        @ds = _gap_stencil($real_aln,@ds);
    }
    my $len = _get_len_from_id_lens($ra_ids);
    my @formatted = ();
    my $seqlen = length($ds[0]->[0]);
    my $numseq = scalar(@{$ds[0]});
    my $header = " $numseq $seqlen\n";
    foreach my $ra_d (@ds) {
        my $aln = $header;
        for (my $i = 0; $i < @{$ra_ids}; $i++) {
            $aln .= sprintf("%${len}s", $ra_ids->[$i]);
            $aln .= "$ra_d->[$i]\n";
        }
        push @formatted, $aln;
    }
    return \@formatted;
}

# IN: alignment file
#    array of sequences
# OUT: array of sequences
# JOB: parse positions of gaps from aln
#      replace chars with gaps in seqs
sub _gap_stencil {
    my $aln = shift;
    my $ra_seqs = shift;
    my $ra_real_seq = _get_seqs_from_seqgen_out($aln,0,0);
    my $count = 0;
    foreach my $sq (@{$ra_real_seq->[0]}) {
        my $string = $sq;
        my $char = '-';
        my $offset = 0;
        my $result = index($string, $char, $offset);
        while ($result != -1) {
            $offset = $result + 1;
            $result = index($string, $char, $offset);
            substr($ra_seqs->[$count],($offset-1),1,'-');
        }
        $count++;
    }
    return $ra_seqs;
}

# IN: array of taxa titles
# OUT: length of titles
# JOB: return lenght of titles for alignment files
sub _get_len_from_id_lens {
    my $ra_ids = shift;
    my $longest = 0;
    foreach my $id (@{$ra_ids}) {
        $longest = length($id) if (length($id) > $longest);
    }
    my $sprintf_val = (($longest + 1) * -1);
    return $sprintf_val;
}

# IN: array of formatted datasets
#     actual alignment file
#     string consisting of rep and run
# OUT: simulated alignment files
# JOB: print array of formatted datasets into alignment files
sub _make_alns {
    my $ra_ds = shift;
    my $aln = shift;
    my $tag = shift;
    my @files = ();
    for (my $i = 0; $i < @{$ra_ds}; $i++) {
        my $file = "$SCRATCH" . "aln.phy.$tag.$i";
        open OUT, ">$file" or _my_die("cannot open >$file:$!");
        print OUT $ra_ds->[$i];
        push @files, $file;
    }
    return \@files;
}

# IN: array of simulated alignments
#     command-line hash of options
#     length of alignments
#     flag for partitioning by codon position
#     iteration
#     restart flag
#     string containing rep and run
# OUT: none
# JOB: if partitioned by codon position, create new partitioning scheme
#      run RAxML on simulated alignments
sub run_gen_trees {
    my $ra_alns = shift;
    my $rh_opts = shift;
    my $ra_aln_len = shift;
    my $codon_flag = shift;
    my $i = shift;
    my $restart = shift;
    my $tag = shift;
    my $part = $rh_opts->{'part'};
    my $mod = $rh_opts->{'mod'};
    my $tre = $rh_opts->{'constraint_tree'};
    if ($rh_opts->{'usegarli'}) {
        _run_garli_on_genset($rh_opts,$ra_alns,$restart,$tag,$i);
        _run_garli_on_genset($rh_opts,$ra_alns,$restart,$tag,$i,$tre);
    } elsif ($codon_flag) {
        my $new_part = "$SCRATCH" . $NEW_PARTITION_FILE;
        my $ra_part_titles = _get_part_titles($part);
        my $ra_ranges = _print_ranges($ra_aln_len);
        _print_new_part_file($ra_part_titles,$ra_ranges,$new_part);
        _run_rax_on_genset($ra_alns,$mod,$new_part,$tre,$i,$restart,$tag);
    } else {
        _run_rax_on_genset($ra_alns,$mod,$part,$tre,$i,$restart,$tag);
    }
}

sub _run_garli_on_genset {
    my $rh_opts = shift;
    my $ra_alns = shift;
    my $restart = shift;
    my $tag = shift;
    my $i = shift;
    my $const = shift;

    my $conf = $rh_opts->{'garli_conf'};
    my ($fh,$file) = File::Temp::tempfile( SUFFIX => '.garli.conf',
                                            UNLINK => 1,
                                            DIR => $SCRATCH);
    open IN, $conf or die "cannot open $conf:$!";
    print $fh "datafname = $ra_alns->[$i]\n";
    if ($const) {
        print $fh "ofprefix = $SCRATCH/t1.$tag.$i\n";
    } else {
        print $fh "ofprefix = $SCRATCH/ml.$tag.$i\n";
    }
    print $fh "searchreps = 1\n";
    print $fh "outputphyliptree = 1\n";
    if ($const) {
        print $fh "constraintfile = $const\n";
    }
    while (my $line = <IN>) {
        next if ($line =~ m/^\s*outputphyliptree\s*=\s/i);
        next if ($line =~ m/^\s*datafname\s*=\s/i);
        next if ($line =~ m/^\s*constraintfile\s*=\s/i);
        next if ($line =~ m/^\s*ofprefix\s*=\s/i);
        next if ($line =~ m/^\s*searchreps\s*=\s/i);
        print $fh $line;
    }
    my $cmd = "$GARLI $file";
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN: parition file
# OUT: array of partition titles
# JOB: parse partition titles
sub _get_part_titles {
    my $part = shift;
    my @titles = ();
    open IN, $part or _my_die("cannot open $part:$!");
    while (my $line = <IN>) {
        chomp $line;
        next if ($line =~ m/^\s*$/);
        if ($line =~ m/^(\s*\S+,\s*\S+\s*=\s*)\d+-\d+\S*\s*$/) {
            my $title = $1;
            push @titles, $title;
        } else {
            _my_die("unexpected line in $part");
        }
    }
    return \@titles;
}

# IN: alignment length
# OUT: array of partition lengths
# JOB: parse partition lengths
sub _print_ranges {
    my $ra_lens = shift;
    my $i = 0;
    my $last = 0;
    my @ranges = ();
    foreach my $d (@{$ra_lens}) {
        my $lt = ($last + 1);
        my $rt = ($last + $d);
        push @ranges, "$lt-$rt";
        $last += $d;
    }
   return \@ranges;
}

# IN: array of partition titles
#     array of partition lengths
# OUT: none
# JOB: print new partition files for codon positions
sub _print_new_part_file {
    my $ra_part_titles = shift;
    my $ra_ranges = shift;
    my $file = shift;
    open OUT, ">$file" or _my_die("cannot open $file:$!");
    for (my $i = 0; $i < @{$ra_ranges}; $i++) {
        print OUT "$ra_part_titles->[$i]";
        print OUT "$ra_ranges->[$i]\n";
    }
}

# IN: array of simulated alignments
#     model
#     partition file
#     tree file
#     iteration
#     restart flag
#     string consisting of rep and run
# OUT: none
# JOB: create command for RAxML
#      run command
#      create command constrained by tree
#      run command
sub _run_rax_on_genset {
    my $ra_alns = shift;
    my $mod     = shift;
    my $part    = shift;
    my $cmd     = '';
    my $tre     = shift;
    my $i       = shift;
    my $restart = shift;
    my $tag     = shift;
    $cmd  = "$RAX -p 1234 -w $SCRATCH -m $mod -s $ra_alns->[$i] ";
    $cmd .= "-n ml.$tag.$i";
    if ($part) {
        $cmd .= " -q $part ";
    }
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
    $cmd  = "$RAX -p 1234 -w $SCRATCH -m $mod -s $ra_alns->[$i] ";
    $cmd .= "-n t1.$tag.$i -g $tre";
    if ($part) {
        $cmd .= " -q $part ";
    }
    if ($QUIET) {
        $cmd .= " >> ${DIR}sowh_stdout_$NAME.txt ";
        $cmd .= "2>> ${DIR}sowh_stderr_$NAME.txt";
    }
    safe_system($cmd) unless($restart);
}

# IN: number of reps
#     filename
#     recalculation flag
#     array of likelihood differences in real data
#     array of likelihood differences in sim data
#     array of mean differences
#     mean difference at last iteration
#     current stopping score
#     last stopping score
#     iteration
#     rep
#     run
# OUT: max likelihood score of new iteration
#      constrained likelihood of new iteration
#      hash of statistical measures
#      array of likelihood differences for this run
#      distribution file
# JOB: set stopping score to last stopping score
#      parse most recent values for null distribution 
#      if recalculate, create distribution of test stats
#      calculate liklihood differences  
#      parse additional statitistics
#      print distribution of differences
sub evaluate_distribution {
    my $reps = shift;
    my $name = shift;
    my $recalc = shift;
    my $ra_delta_dist = shift;
    my $ra_deltaprime_dist = shift;
    my $ra_mean = shift;
    my $ra_var = shift;
    my $ra_stdev = shift;
    my $ra_rse = shift;
    my $ra_ks = shift;
    my $ra_current_score = shift;
    my $ra_pen_score = shift;
    my $i = shift;
    my $ts = shift;
    my $ch = shift;
    my $tag = shift;
    my $rh_opts = shift;
    my $best_ml_score = 0;
    my $best_t1_score = 0;

    $ra_pen_score->[$ch] = $ra_current_score->[$ch];

    my ($ra_dist,$ra_const_dist);
    if ($rh_opts->{'usegarli'}) {
        $ra_dist = _get_distribution_from_garli($reps,0,$i,$tag);
        $ra_const_dist = _get_distribution_from_garli($reps,1,$i,$tag);
    } else {
        $ra_dist = _get_distribution($reps,0,$i,$tag);
        $ra_const_dist = _get_distribution($reps,1,$i,$tag);
    }

    if ($rh_opts->{'usegarli'} && $recalc) {
        $best_ml_score = _get_best_garli_score("$SCRATCH" . "ml.$tag.screen.log");
        $best_t1_score = _get_best_garli_score("$SCRATCH" . "t1.$tag.screen.log");
        $ra_delta_dist->[$ch][$ts] = $best_ml_score - $best_t1_score;
         
    } elsif ($rh_opts->{'usegarli'}) {
        $best_ml_score = _get_best_garli_score("$SCRATCH" . "ml.0.0.screen.log");
        $best_t1_score = _get_best_garli_score("$SCRATCH" . "t1.0.0.screen.log");
        $ra_delta_dist->[$ch][$ts] = $best_ml_score - $best_t1_score;
        
    } elsif ($recalc) {
        $best_ml_score = _get_best_score("$SCRATCH" . "RAxML_info.ml.$tag");
        $best_t1_score = _get_best_score("$SCRATCH" . "RAxML_info.t1.$tag");
        $ra_delta_dist->[$ch][$ts] = $best_ml_score - $best_t1_score;
    } else {
        $best_ml_score = _get_best_score("$SCRATCH" . "RAxML_info.ml.0.0");
        $best_t1_score = _get_best_score("$SCRATCH" . "RAxML_info.t1.0.0");
        $ra_delta_dist->[$ch][0] = $best_ml_score - $best_t1_score;
    }

    # next 2 lines avoid uninitialized errors
    $ra_dist->[$i] = $ra_dist->[$i] || 0;
    $ra_const_dist->[$i] = $ra_const_dist->[$i] || 0;

    $ra_deltaprime_dist->[$ch][$ts] = $ra_dist->[$i] - $ra_const_dist->[$i];

    my $rh_stats = _get_stats($ra_delta_dist->[$ch],$ra_deltaprime_dist->[$ch]);
    $ra_mean->[$ch][$ts] = $rh_stats->{'mean'};
    $ra_var->[$ch][$ts] = $rh_stats->{'var'};
    $ra_stdev->[$ch][$ts] = $rh_stats->{'stdev'};
    $ra_rse->[$ch][$ts] = $rh_stats->{'rse'};
    $ra_ks->[$ch][$ts] = $rh_stats->{'ks'};

    $ra_current_score->[$ch] = $rh_stats;

    my $fd_file = _print_freq_dist($ra_deltaprime_dist->[$ch],$name,$reps);
    return ($best_ml_score,$best_t1_score,$rh_stats,$ra_deltaprime_dist->[$ch],$fd_file);
}

# IN: number of repetitions
#     flag for constrained ml score
#     iteration
#     string consisting of rep and run
# OUT: array of likelihood scores
# JOB: parse likelihood scores from RAxML output
sub _get_distribution_from_garli {
    my $reps = shift;
    my $w_const = shift;
    my $j = shift;
    my $tag = shift;
    my @dist = ();
    for (my $i = 0; $i <= $j; $i++) {
        my $file = '';
        if ($w_const) {
            $file = "$SCRATCH" . "t1.$tag.$i.screen.log";
        } else {
            $file = "$SCRATCH" . "ml.$tag.$i.screen.log";
        }
        open IN, $file or _my_die("cannot open $file:$!");
        while (my $line = <IN>) {
            if ($line =~ m/^Final score = (\S+)/) {
                my $likelihood = $1;
                _my_die("unexpected multiple matches in $file") if ($dist[$i]);
                $dist[$i] = $likelihood;
            }
            chomp $line;
        }
    }
    return \@dist;
}

# IN: number of repetitions
#     flag for constrained ml score
#     iteration
#     string consisting of rep and run
# OUT: array of likelihood scores
# JOB: parse likelihood scores from RAxML output
sub _get_distribution {
    my $reps = shift;
    my $w_const = shift;
    my $j = shift;
    my $tag = shift;
    my @dist = ();
    for (my $i = 0; $i <= $j; $i++) {
        my $file = '';
        if ($w_const) {
            $file = "$SCRATCH" . "RAxML_info.t1.$tag.$i";
        } else {
            $file = "$SCRATCH" . "RAxML_info.ml.$tag.$i";
        }
        open IN, $file or _my_die("cannot open $file:$!");
        while (my $line = <IN>) {
            if ($line =~ m/^Inference\[0\] final[^:]+: ([-0-9.]+)/) {
                my $likelihood = $1;
                _my_die("unexpected multiple matches in $file") if ($dist[$i]);
                $dist[$i] = $likelihood;
            }
            chomp $line;
        }
    }
    return \@dist;
}

# IN: filename
# OUT: likelihood score
# JOB: parse likelihood score of real data
sub _get_best_garli_score {
    my $file = shift;
    my $ml_score = '';
    open IN, $file or _my_die("cannot open $file:$!");
    while (my $line = <IN>) {
        chomp $line;
        if ($line =~ m/^Final score = (\S+)/) {
            $ml_score = $1;
        }
    }
    die "could not get ml score from garli ($file)" unless ($ml_score);
    return $ml_score;
}


# IN: filename
# OUT: likelihood score
# JOB: parse likelihood score of real data
sub _get_best_score {
    my $file = shift;
    my $ml_score = '';
    open IN, $file or _my_die("cannot open $file:$!");
    while (my $line = <IN>) {
        chomp $line;
        if ($line =~ m/^Final GAMMA-based Score of best tree (\S+)/) {
            $ml_score = $1;
        }
        if ($line =~ m/^Final ML Optimization Likelihood: (\S+)/) {
            $ml_score = $1;
        }
    }
    return $ml_score;
}

# IN: array of test statistics
#     array of null distribution
# OUT: hash of statistics
# JOB: run R for statistical test
sub _get_stats {
    my $ra_delta_dist = shift;
    my $ra_deltaprime_dist = shift;

    my $ts = scalar(@{$ra_deltaprime_dist});
    my $delta_string = @{$ra_delta_dist};
    my $deltaprime_string = @{$ra_deltaprime_dist};

    if($ts > 1) {
        $delta_string = join ', ', @{$ra_delta_dist};
        $deltaprime_string = join ', ', @{$ra_deltaprime_dist};
    }



    my $R = Statistics::R->new();
    $R->startR();
     
    my $cmds = <<EOF;
    options(warn=-1)
    statmean <- mean(c($deltaprime_string))
    statsd <- sd(c($deltaprime_string))
    statnum <- $ts
    stattest <- mean(c($delta_string))
    oldz <- (stattest - statmean)/(statsd/sqrt(statnum))
    oldp <-  pnorm(oldz, lower.tail = FALSE)
    statvar <- var(c($deltaprime_string))
    statse <- (statsd/sqrt(statnum))
    statrse <- abs((statse/statmean) * 100)
    x <- c()
    ksmean <- 0
    if (statnum > 4) {
        for (i in 1:100) {
            half1 <- sample(c($deltaprime_string),statnum/2)
            half2 <- setdiff(c($deltaprime_string),half1)
            ks <- ks.test(half1,half2)
            ksp <- ks\$p.value
            x[i] <- ksp
            ksmean <- mean(x)
        }
    }
    statmean
    statsd
    statnum
    stattest
    oldp
    statvar
    statse
    statrse
    ksmean
EOF
    my $r_out = $R->run($cmds);
    $R->stopR();
    my $rh_stats = _parse_stats($r_out);
    return $rh_stats;
}

# IN: output of R
# OUT: hash of statistics
# JOB: parse R output
sub _parse_stats {
    my $str = shift;
    my %stats = ();
    $str =~ s/^\[\d+\] // or warn "unexpected output from R";
    my @data = split /\n\[\d+\] /, $str;
    $stats{'mean'} = $data[0];
    $stats{'stdev'} = $data[1];
    $stats{'sample_size'} = $data[2];
    $stats{'diff'} = $data[3];
    $stats{'oldp'} = $data[4];
    $stats{'var'} = $data[5];
    $stats{'se'} = $data[6];
    $stats{'rse'} = $data[7];
    $stats{'ks'} = $data[8];
    return \%stats;
}

# IN: array of null distribution
#     filename
#     string consisting of rep and run
# OUT: distribution filename
# JOB: print null distribution
sub _print_freq_dist {
    my $ra_d = shift;
    my $name = shift;
    my $tag = shift;
    my %bins = ();
    my @sorted = sort {$a <=> $b} @{$ra_d};
    my $low  = $sorted[0];
    my $high = $sorted[-1];
    my $div = ($high - $low) / $FREQ_BIN_NUMBER;
    my $current_bin = $low;
    my $i = 0;
    while ($i < @sorted) {
        if ($sorted[$i] > ($current_bin + $div)) {
           $current_bin += $div
        } else {
            $bins{$current_bin}++;
        }
        $i++;
    }
    my $d_file = "$DIR" . "sowhat.distribution";
    open OUT, ">$d_file" or _my_die("cannot open >$d_file:$!");
    print OUT "Null Distribution Frequencies:\n";
    foreach my $bin (sort {$a <=> $b} keys %bins) {
        print OUT "$bin\t$bins{$bin}\n";
    }
    print OUT "\nNull Distribution\n";
    foreach my $dist_val (@sorted) {
        print OUT "$dist_val\n";
    }
    close OUT;
    return $d_file;
}

# IN: array of cumulative mean of null dist
#     runs
#     reps
# OUT: none
# JOB: plot cumulative mean of all runs
sub plot_runs {
    my $ra_mean = shift;
    my $runs = shift;
    my $ts = shift;
    my $R = Statistics::R->new();
    my $ra_mean_str = ();
    my $i = 0;
    if(scalar($ts > 0)) {
        foreach(@{$ra_mean}) {
            $ra_mean_str->[$i] = "m[,($i + 1)] <- c(" . join ( ', ', @{$ra_mean->[$i]}) . ');';
            $i++;
        }
        my $ra_str = join ( "\n", @{$ra_mean_str});
        $R->startR();
  
        my $cmds = <<EOF;
m <- data.frame(row.names=1:($ts + 1))
$ra_str
postscript("$DIR/allmeans.$runs.eps",horizontal = FALSE, onefile = FALSE, paper = "special",width=6.0,height=6.0)
par(mar=c(5, 4, 4, 2) + 0.1)
plot(m[,1],ylim=c(min(m),max(m)),type="l",ylab="Cumulative Mean of Null Distribution", xlab="Sample Size") 
for (i in 2:$runs){
lines(m[,i],type="l",col=i)
}
dev.off()
EOF
        my $r_out = $R->run($cmds);
        $R->stopR();
    }
}

# IN: run
#     rep
#     current stopping score
#     last stopping score
#     ratio of current score to last
#     array of mean values
# OUT: none
# JOB: calculate stopping ratio
#      plot stopping ratio of each run
#      plot cumulative mean of each run 
sub calc_ratio {
    my $ch = shift;
    my $ts = shift;
    my $ra_current_score = shift;
    my $ra_pen_score = shift;
    my $ratio_mean = shift;
    my $ratio_var = shift;
    my $ratio_stdev = shift;
    my $ratio_rse = shift;
    my $ra_mean = shift;
    my $ra_var = shift;
    my $ra_stdev = shift;
    my $ra_rse = shift;
    my $ra_ks = shift;
    
    my $rh_current = $ra_current_score->[$ch];
    my $rh_pen= $ra_pen_score->[$ch];
    
    $ratio_mean->[$ch][$ts] = abs(1-($rh_current->{'mean'} / $rh_pen->{'mean'}));
    $ratio_var->[$ch][$ts] = abs(1-($rh_current->{'var'} / $rh_pen->{'var'}));
    $ratio_stdev->[$ch][$ts] = abs(1-($rh_current->{'stdev'} / $rh_pen->{'stdev'}));
    $ratio_rse->[$ch][$ts] = abs(1-($rh_current->{'rse'} / $rh_pen->{'rse'}));

    for(my $j=0; $j < 11; $j++) {
        $ratio_mean->[$ch][$j] = 0;
        $ratio_var->[$ch][$j] = 0;
        $ratio_stdev->[$ch][$j] = 0;
        $ratio_rse->[$ch][$j] = 0;
        $ra_mean->[$ch][$j] = 0;
        $ra_var->[$ch][$j] = 0;
        $ra_stdev->[$ch][$j] = 0;
        $ra_rse->[$ch][$j] = 0;
        $ra_ks->[$ch][$j] = 0;
    }

    my $ratio_m = $ratio_mean->[$ch];
    my $ratio_v = $ratio_var->[$ch];
    my $ratio_s = $ratio_stdev->[$ch];
    my $ratio_r = $ratio_rse->[$ch];

    my $ra_m = $ra_mean->[$ch];
    my $ra_v = $ra_var->[$ch];
    my $ra_s = $ra_stdev->[$ch];
    my $ra_r = $ra_rse->[$ch];
    my $ra_k = $ra_ks->[$ch];

    if(scalar(@{$ra_m}) > 1) {
        my $ratio_mean_str = join ', ', @{$ratio_m};
        my $ratio_var_str = join ', ', @{$ratio_v};
        my $ratio_stdev_str = join ', ', @{$ratio_s};
        my $ratio_rse_str = join ', ', @{$ratio_r};

        my $mean_str = join ', ', @{$ra_m};
        my $var_str = join ', ', @{$ra_v};
        my $stdev_str = join ', ', @{$ra_s};
        my $rse_str = join ', ', @{$ra_r};
        my $ks_str = join ', ', @{$ra_k};
    
        my $file = "$DIR" . "stopping.stats.r";
        open OUT, ">$file" or _my_die("cannot open >$file:$!");
        print OUT "rationull <- c($ratio_mean_str)\n";
        print OUT "postscript(\"$DIR/ratiom.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(rationull,ylim=c(min(rationull),max(rationull)),ylab=\"1 - Ratio\", xlab=\"Sample Size\",pch=20)\n"; 
        print OUT "dev.off()\n";
        print OUT "rationull <- c($ratio_var_str)\n";
        print OUT "postscript(\"$DIR/ratiov.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(rationull,ylim=c(min(rationull),max(rationull)),ylab=\"1 - Ratio\", xlab=\"Sample Size\",pch=20)\n"; 
        print OUT "dev.off()\n";
        print OUT "rationull <- c($ratio_stdev_str)\n";
        print OUT "postscript(\"$DIR/ratios.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(rationull,ylim=c(min(rationull),max(rationull)),ylab=\"1 - Ratio\", xlab=\"Sample Size\",pch=20)\n"; 
        print OUT "dev.off()\n";
        print OUT "rationull <- c($ratio_rse_str)\n";
        print OUT "postscript(\"$DIR/ratior.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(rationull,ylim=c(min(rationull),max(rationull)),ylab=\"1 - Ratio\", xlab=\"Sample Size\",pch=20)\n"; 
        print OUT "dev.off()\n";
        print OUT "meannull <- c($mean_str)\n";
        print OUT "postscript(\"$DIR/mean.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(meannull,type=\"l\",ylim=c(min(meannull),max(meannull)),ylab=\"Cumulative Mean of Null Distribution\", xlab=\"Sample Size\")\n"; 
        print OUT "dev.off()\n";
        print OUT "meannull <- c($var_str)\n";
        print OUT "postscript(\"$DIR/var.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(meannull,type=\"l\",ylim=c(min(meannull),max(meannull)),ylab=\"Cumulative Mean of Null Distribution\", xlab=\"Sample Size\")\n"; 
        print OUT "dev.off()\n";
        print OUT "meannull <- c($stdev_str)\n";
        print OUT "postscript(\"$DIR/stdev.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(meannull,type=\"l\",ylim=c(min(meannull),max(meannull)),ylab=\"Cumulative Mean of Null Distribution\", xlab=\"Sample Size\")\n"; 
        print OUT "dev.off()\n";
        print OUT "meannull <- c($rse_str)\n";
        print OUT "postscript(\"$DIR/rse.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(meannull,type=\"l\",ylim=c(min(meannull),max(meannull)),ylab=\"Cumulative Mean of Null Distribution\", xlab=\"Sample Size\")\n"; 
        print OUT "dev.off()\n";
        print OUT "meannull <- c($ks_str)\n";
        print OUT "postscript(\"$DIR/ks.$ch.eps\",horizontal = FALSE, onefile = FALSE, paper = \"special\",width=4.0,height=4.0)\n";
        print OUT "par(mar=c(5, 4, 4, 2) + 0.1)\n";
        print OUT "plot(meannull,type=\"l\",ylim=c(min(meannull),max(meannull)),ylab=\"Cumulative Mean of Null Distribution\", xlab=\"Sample Size\")\n"; 
        print OUT "dev.off()\n";

    }
}

# IN: run
#    rep
#    real max likelihood score
#    real constrained score
#    hash of statistics
#    array of test statistics
#    array of null distribution
#    array of stopping ratios
#    hash of command-line options
#    frequency filename
#    stopping ratio count
#    stopping ration percent
#    mc count
#    mc p-value
#    version
# OUT: none
# JOB: calculate percent of stopping score to sample
#      print report
sub print_report {
    my $ch = shift;
    my $ts = shift;
    my $best_ml = shift;
    my $const_ml = shift;
    my $rh_s = shift;
    my $ra_d = shift;
    my $current_d = $ra_d->[$ts];
    my $ra_delta_dist = shift;
    $ra_delta_dist = $ra_delta_dist->[$ch];
    my $ratio_mean = shift;
    my $ratio_var = shift;
    my $ratio_stdev = shift;
    my $ratio_rse = shift;
    my $rh_opts = shift;
    my $fd_file = shift;
    my $ra_ratio_count = shift;
    my $ra_perc_ratio = shift;
    my $ra_mc_count = shift;
    my $ra_pval_mc = shift;
    my $version = shift;
    my $ratio = $ratio_rse->[$ch][$ts];
    my $file = '';

    if ($rh_opts->{'runs'} > 1) {
        $file = $DIR . "sowhat.results.$ch";  
    } else {
        $file = $DIR . "sowhat.results";
    }

    if($ratio <= 0.01) {
        print "o";
        $ra_ratio_count->[$ch]++;
    } else {
        print ".";
    }

    if($current_d >= $rh_s->{'diff'}) {
        $ra_mc_count->[$ch]++;
    }

    $ra_ratio_count->[$ch] = $ra_ratio_count->[$ch] || 0;
    $ra_mc_count->[$ch] = $ra_mc_count->[$ch] || 0;
    
    $ra_perc_ratio->[$ch] = ($ra_ratio_count->[$ch] / $rh_s->{'sample_size'}) * 100;
    $ra_pval_mc->[$ch]    = ($ra_mc_count->[$ch] / $rh_s->{'sample_size'});
    if($ra_perc_ratio->[$ch] > 50 && $rh_s->{'sample_size'} > 100) {
        exit if($rh_opts->{'stop'});
    }
    open OUT, ">$file" or _my_die("cannot open >$file:$!");
    print OUT "\n\n";
    print OUT "=============================================================\n";
    print OUT "                   sowhat OUTPUT\n";
    print OUT "=============================================================\n\n";
    print OUT "\n\nProgram was called as follows:\n$0 \\\n";
    foreach my $arg (@{$rh_opts->{'orig_options'}}) {
        print OUT "  $arg \\\n";
    }
    print OUT "\n  \$SEQGEN variable set to $SEQGEN\n";
    if ($rh_opts->{'usegarli'}) {
        print OUT "  \$GARLI variable set to $GARLI\n";
        print OUT "  garli was version $version\n";
    } else {
        print OUT "  \$RAX variable set to $RAX\n";
        print OUT "  RAxML was version $version\n";
    }
    print OUT "\nDistributions and frequencies printed to:\n $fd_file\n";
    print OUT "\nTest Statistic:\n";
    print OUT "    ML value of best tree: $best_ml\n";
    print OUT "    ML value of best tree w/constraint: $const_ml\n";
    print OUT "    Difference between $best_ml and $const_ml: $rh_s->{'diff'}\n";
    print OUT "\nStatistics of the null distribution:\n";
    print OUT "    Size of null distribution: $rh_s->{'sample_size'}\n";
    print OUT "    Mean of null distribution: $rh_s->{'mean'}\n";
    print OUT "    Standard deviation of null distribution: $rh_s->{'stdev'}\n";
    print OUT "    Standard error of null distribution: $rh_s->{'se'}\n";
    print OUT "    Relative standard error: $rh_s->{'rse'}" . "%\n";
    print OUT "    Variance of null distribution: $rh_s->{'var'}\n";
    print OUT "\nStopping Criteria:\n";
    print OUT "    The value of 1 - ratio of z-scores as the sample size increases\n";
    print OUT "    will approach 0. The percent of iterations which return values\n";
    print OUT "    of 1-ratio < 0.01 is shown. Sufficient sampling is >50%\n";
    print OUT "    Percent Ratio: $ra_perc_ratio->[$ch]" . "%\n";
    print OUT "\nSOWH test results:\n";
    print OUT "    The p-value represents the probability that the test statistic\n";
    print OUT "    would be observed under the null hypothesis.\n";
    print OUT "\n    Monte Carlo count $ra_mc_count->[$ch]\n";
    print OUT "    Monte Carlo p-value: $ra_pval_mc->[$ch]\n";
    print OUT "\n    Parametric test p-value: $rh_s->{'oldp'}\n";
    close OUT;
    open OUT, ">>$fd_file" or _my_die("cannot open >$fd_file:$!");
    print OUT "\nNull Distribution:\n";
    foreach my $val (@{$ra_d}) {
       print OUT "$val\n";
    }
    print OUT "\nDistribution of Test Statistics:\n" if($ra_delta_dist);
    foreach my $val (@{$ra_delta_dist}) {
       print OUT "$val\n";
    }
    close OUT;
}

# IN: message
# OUT: none
# JOB: warn when file cannot be opened
sub _my_die {
    my $msg  = shift;
    my $file = "${DIR}sowh_stderr_$NAME.txt";
    open IN, $file or warn "cannot open $file:$!";
    while (my $line = <IN>) {
        warn $line;
    }
    warn "sowhat died unexpectedly\n";
    die $msg;
}

sub usage {
    die "usage: $0
    --constraint=NEWICK_CONSTRAINT_TREE
    --aln=PHYLIP_ALIGNMENT
    --name=NAME_FOR_REPORT
    --model=MODEL
    --dir=DIR
    --max
    [--rax=RAXML_BINARY_OR_PATH_PLUS_OPTIONS]
    [--seqgen=SEQGEN_BINARY_OR_PATH_PLUS_OPTIONS]
    [--usegarli]
    [--garli=GARLI_BINARY_OR_PATH_PLUS_OPTIONS]
    [--garli_conf=PATH_TO_GARLI_CONF_FILE]
    [--usepb]
    [--stop]
    [--pb=PB_BINARY_OR_PATH_PLUS_OPTIONS]
    [--pb_burn=BURNIN_TO_USE_FOR_PB_TREE_SIMULATIONS]
    [--reps=NUMBER_OF_REPLICATES]
    [--runs=NUMBER_OF_RUNS]
    [--partition=PARTITION_FILE]
    [--rerun]
    [--restart]
    [--nogaps]
    [--debug]
    [--help]
    [--version]\n";
}

__END__

=head1 NAME

B<sowhat> - The SOWH-Test: A Paramentric Test of Topologies

=head1 AUTHOR

Samuel H. Church <samuel_church@brown.edu>, Joseph F. Ryan <joseph.ryan@whitney.ufl.edu>, Casey W. Dunn <casey_dunn@brown.edu>

=head1 SYNOPSIS 

sowhat --constraint=NEWICK_CONSTRAINT_TREE --aln=PHYLIP_ALIGNMENT --name=NAME_FOR_REPORT --model=MODEL --dir=DIR [--max] [--rax=RAXML_BINARY_OR_PATH_PLUS_OPTIONS] [--seqgen=SEQGEN_BINARY_OR_PATH_PLUS_OPTIONS] [--usegarli] [--garli=GARLI_BINARY_ORPATH_PLUS_OPTIONS] [--garli_conf=PATH_TO_GARLI_CONF_FILE] [--usepb] [--pb=PB_BINARY_OR_PATH_PLUS_OPTIONS] [--pb_burn=BURNIN_TO_USE_FOR_PB_TREE_SIMULATIONS] [--reps=NUMBER_OF_REPLICATES] [--runs=NUMBER_OF_RUNS] [--partition=PARTITION_FILE] [--rerun] [--debug] [--help] [--version]\n";

=head1 constraint

=over 2

This programs is designed to test a hypothesized topology, here provided as a constraint tree, against the best topology obtained in a maximum likelihood analysis of the data.

=back

=head1 aln

=over 2

This file is the alignment file which will be used to estimate likelihood scores and free parameters. This alignment file must be in phylip format.

=back

=head1 name

=over 2

This is the name of the output files.

=back

=head1 model

=over 2

This is the model which will be used to estimate the likelihood scores of the original dataset the scores of each of the generated datasets with and without the topology constrained according to the hypothesis. GammaGTR is used to generate parameters for null dataset regardless of the model specified (unless --usepb is specified, in which case phylobayes is used to generate parameters).

=back

=head1 dir

=over 2

This is the directory where ouput files will be sent.

=back

=head1 OPTIONS

=over 2

=item B<--max>
This option maximizes the number of free parameters used for simulations. 

=item B<--rax>

<default: raxmlHPC>
This allows the user to specify the RAxML binary to be used in the analysis. It is useful if a user would like to specify the full path to a RAxML binary, but its purpose is mostly to allow users to run a multi-threaded or MPI version of the program, and or pass additional parameters to RAxML. Some examples would be:

    --rax='raxmlHPC-PTHREADS-SSE3 -T 8'

    --rax='mpirun -n 8 raxmlHPC-MPI'

=item B<--seqgen>

<default: seq-gen>
This allows the user to specify the SeqGen binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to seq-gen

=item B<--usepb>

Use PhyloBayes (pb and ppred programs) to calculate null distribution parameters and generate data sets instead of using RAxML and Seq-Gen. Only works for amino acid and nucleotide datasets (not character data)

=item B<--pb>

<default: pb>
This allows the user to specify the pb binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to pb (only useful with --usepb)

=item B<--usegarli>

Use GARLI instead of RAXML for nucleotide data.

=item B<--garli>

<default: garli>
This allows the user to specify the garli binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to garli (only useful with --usegarli)

=item B<--garli_conf=PATH_TO_GARLI_CONF_FILE>
If using garli (--usegarli) a garli conf file must be supplied (see examples directory of sowhat distribution for example)

=item B<--stop>

This option allows the program to stop when sufficient sample size is reached, under a given stopping criterion. The value of reps is the maximum number of simulations the program will calculate. This is measured by comparing the frequency of iterations of simulation which return non-extreme values, as measured by calculating 1 - the ratio of z-scores after each new simulation is added. The plot of this ratio is included as ratio.eps

=item B<--ppred>

<default: ppred>
This allows the user to specify the ppred binary or path to the binary to be used in the analysis. It could be useful to pass additional parameters to ppred (only useful with --usepb)

=item B<--pb_burn>

<default: 10>
This allows the user to specify the burn-in value used for the phylobayes analysis (only useful with --usepb)

=item B<--reps>

<default: 1000>
This is the number of datasets which will be generated according to the estimated parameters. This number represents the sample size of the distribution. Each dataset will be evaluated twice for a likelihood score, once with and once without the topology constrained. If using the SOWHat alternative, this is the number of test statistics that will be calculated, the number of times the parameters will be optimized, as well as the number of new alignments that will be generated.

=item B<--runs>
<default: 1>
This is the number of runs. 

=item B<--partition>

This can be a partition file which applies to the dataset. It must be in a format recognizable by RAxML version 7.7.0.

=item B<--rerun>

This option will adjust the SOWH test to account for variability in the maximum likelihood search. In this option, the test statistic and parameters will be recalculated for each alignment generated. The mean test statistic will then be tested against the null distribution using a one tailed test, similar to the SOWH test.

=item B<--restart>

This option allows the user to restart a test without reconstructing the null distribution. The final two iterations are removed to eliminate any trees not fully completed. The statistics will be parsed again from the output files of RAxML and the report will be calculated at each iteration.
=item B<--nogaps>

By default sowhat will propogate the undetermined sites in the original dataset into all simulated datasets before they are evaluted.  Use this option to turn this behavior off. Simulated datasets will have no gaps.

=item B<--debug>

do not redirect standard out and standard error. RAxML in particular will produce lots of output with this option. Can be useful for debugging problems like, for example, bad tree format.

=item B<--help>

Print this manual

=item B<--version>

Print the version. Overrides all other options.

=back

=head1 DESCRIPTION

This program automates the steps required for the SOWH test (as described by Goldman et. al., 2000. It depends on the freely available seq-gen and RAxML software packages. It works on amino acid, nucleotide, and binary character state datasets. Partitions can be specified. It can also use PhyloBayes to simulate the null distribution.

The program calculates the difference between two likelihood scores: that of the best tree, and the best tree constrained by the hypothesized topology. The maximum likelihodd analyses are run using RAxML, a phylogenetic tool written by Alexandros Stamatakis, and freely available under GNU GPL lisence. See:
https://github.com/stamatak/RAxML-Light-1.0.5

This program then generates new alignments based on the hypothesized topology and the maximum number of free parameters from the constrained topology, including branch lengths as well as the frequencies, transtition rates, and alpha values (if available, partitions are taken into account). These datasets are generated using seq-gen, written by Andrew Rambaut and Nick C. Grassly. It is freely available under BSD license, see: 
http://tree.bio.ed.ac.uk/software/seqgen/

The program then calculates the likelihood scores of each of these alignments both with and without the topology constrained according to the hypothesis. The differences between these scores become the distributions against which the test value will be evaluated.

+The p-value of the test statistic is calculated using R, using the pnorm function. Information about the test is printed to the file sowhat.results in the directory specified by the user. The variance of the null distribution is printed to variance.eps.

R is freely available under the GPL-2 license.

Nick Goldman, Jon P. Anderson, and Allen G. Rodrigo
Likelihood-Based Tests of Topologies in Phylogenetics
Syst Biol (2000) 49 (4): 652-670 doi:10.1080/106351500750049752

Here is an example command using the test datasets:

=over 2

perl sowhat ...

=back

=head1 BUGS

Please report them to any or all of the authors.

=head1 COPYRIGHT

Copyright (C) 2012,2013 Samuel H. Church, Joseph F. Ryan, Casey W. Dunn

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
